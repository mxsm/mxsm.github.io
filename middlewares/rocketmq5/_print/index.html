<!doctype html><html lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.83.1"><link rel=canonical type=text/html href=/middlewares/rocketmq5/><link rel=alternate type=application/rss+xml href=/middlewares/rocketmq5/index.xml><meta name=ROBOTS content="INDEX, FOLLOW"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Apache RocketMQ5 | 蚂蚁背大象</title><meta property="og:title" content="Apache RocketMQ5"><meta property="og:description" content="Apache RocketMQ5 blog"><meta property="og:type" content="website"><meta property="og:url" content="/middlewares/rocketmq5/"><meta property="og:site_name" content="蚂蚁背大象"><meta itemprop=name content="Apache RocketMQ5"><meta itemprop=description content="Apache RocketMQ5 blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Apache RocketMQ5"><meta name=twitter:description content="Apache RocketMQ5 blog"><link rel=preload href=/scss/main.min.e09cb23c7dff3bf1285aa0294bcdc4ac8194fb3425a99c621e31e7b871315685.css as=style><link href=/scss/main.min.e09cb23c7dff3bf1285aa0294bcdc4ac8194fb3425a99c621e31e7b871315685.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 321.39 78.54"><title id="title19">DUBBO LOGO</title><path class="cls-1" d="M68.46 50.38c0 14.06 11.39 22.11 25.45 22.11s25.45-8.05 25.45-22.11V7.25H68.46zm21.24-28h8.6V31H89.7zm0 22.25h8.6v8.6H89.7zM33.24 7.25H4.06v64H33.24c10.95.0 19.3-7.18 23.29-17.15a45.12 45.12.0 002.38-14.87A45.12 45.12.0 0056.53 24.4C52.84 14.62 44.19 7.25 33.24 7.25zm.43 14.63H30.34a3.44 3.44.0 00-3.44 3.44V53.23a3.44 3.44.0 003.44 3.44h3.33v4.63h-8.3a6.87 6.87.0 01-6.87-6.87V24.12a6.87 6.87.0 016.87-6.87h8.3zM285.51 6.06c-17.05.0-30.88 10.28-30.88 33.21s13.83 33.21 30.88 33.21 30.88-10.28 30.88-33.21S302.56 6.06 285.51 6.06zm7.59 48.36a6.87 6.87.0 01-6.87 6.87h-8.3V56.67h3.33a3.44 3.44.0 003.44-3.44V25.31a3.44 3.44.0 00-3.44-3.44h-3.33V17.25h8.3a6.87 6.87.0 016.87 6.87zm-53.4-17.56A17.39 17.39.0 00227.31 7.25H195.1v64h32.21a19.44 19.44.0 0012.38-34.44zM211.63 61.29h-6.08l18.68-44h6.08zM177 36.85A17.39 17.39.0 00164.65 7.25H132.43v64h32.21A19.44 19.44.0 00177 36.85zM149 61.29h-6.08l18.68-44h6.08z" style="fill:#fff;fill-opacity:1"/></svg></span><span class="text-uppercase font-weight-bold">蚂蚁背大象</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/about/><span>Home</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/blog/><span>Java</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/spring/><span>Spring</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class="nav-link active" href=/middlewares/><span class=active>Middleware</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/docs/><span>Documentation</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/other/><span>Others</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/community/><span>Community</span></a></li></ul></div><div class="navbar-nav d-none d-lg-block"><input type=search class="form-control td-search-input" placeholder="&#xf002 站内搜索…" aria-label=站内搜索… autocomplete=off></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/middlewares/rocketmq5/>Return to the regular view of this page</a>.</p></div><h1 class=title>Apache RocketMQ5</h1><div class=lead>Apache RocketMQ5 blog</div><ul><li>1: <a href=#pg-54f8ddbd705cd357ca76b24eda088e75>RocketMQ5.0 Quick start</a></li><ul><li>1.1: <a href=#pg-063f616dc17c5981b9913026f79f354d>RocketMQ5.0 Controller DLedger模式</a></li></ul><li>2: <a href=#pg-99e54084096a24c513ec816aec143554>RocketMQ5.0 Store</a></li><ul><li>2.1: <a href=#pg-183998bd110bc38c9f3589fe0b8f1b7c>RocketMQ5.0-CommitLog设计与源码解析</a></li><li>2.2: <a href=#pg-90b8826930eefcca2856d10acd2892bc>RocketMQ5.0源码分析-AutoSwitchHAClient</a></li><li>2.3: <a href=#pg-39b03f14225919dbe9d2ceb73847296b>RocketMQ5.0源码解析-CommitLog设计与几个重要的属性关系图文解析</a></li></ul><li>3: <a href=#pg-bae99819ba415c77ab3209bbe2a910b4>RocketMQ5.0主备自动切换模式Broker选主详解</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-54f8ddbd705cd357ca76b24eda088e75>1 - RocketMQ5.0 Quick start</h1><div class=lead>Apache RocketMQ5.0 笔记文档</div><p>主要说明如何快速开始使用一些RocketMQ5.0版本一些新的特性。以及如何快速开启在本地进行开发联调的说明。这个也是笔者在参与RocketMQ5开发的过程中使用的方法。这里主要针对两大平台：<code>Windows</code> 和 <code>Linux(MacOS)</code></p></div><div class=td-content style=page-break-before:always><h1 id=pg-063f616dc17c5981b9913026f79f354d>1.1 - RocketMQ5.0 Controller DLedger模式</h1><p>RocketMQ5.0已经发布，在RocketMQ5.0新增了一个新的高可用模式 <strong>DLedger Controller</strong> 模式。下面就来聊一下RocketMQ5.0新增的这个模式。</p><h3 id=1-背景>1. 背景</h3><p>首先我们需要知道<strong>DLedger Controller</strong> 是为了解决什么问题，先来看一下之前版本的DLedger模式架构图：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/quickstart/raft-modle.png alt=raft-modle></p><p>在 DLedger 模式下，利用 Raft Commitlog 代替了原来的 Commitlog 了，使得 Commmitlog 具备了选举的能力，当 Master Broker 故障后，通过内部协商，从其他的 Slave Broker 中选出新的 Master，完成主备切换，同时 Raft 的算法也保证了 Commitlog 的一致性。但是存在一些缺点：</p><ul><li>想要具备选举切换的能力，单组 Broker 内的副本数必须 3 副本及以上(Raft协议决定)</li><li>副本 ACK 需要严格遵循 Raft 协议多数派的限制，3 副本需要 2 副本 ACK 后才能返回，5 副本需要 3 副本 ACK 后才能返回，副本越多可能耗时也可能越长。(这个也是最重要的一点)</li><li>DLedger 模式下，由于存储库使用了 OpenMessaging DLedger 存储，因此无法复用 RocketMQ 原生的存储和复制的能力（比如 transientStorePool 和零拷贝能力），且对维护造成了困难。</li></ul><p>在RocketMQ5.0版本新增了DLedger Controller模式来解决上面对的痛点。</p><h3 id=2-dledger-controller模式架构>2. DLedger Controller模式架构</h3><p>DLedger Controller模式的核心思想：将其作为一个选主组件，并且是一个 <strong>可选择、松耦合</strong> 的组件。当部署 DLedger Controller 组件后，原本 Master-Slave 部署模式下 Broker 组就拥有 Failover 能力。</p><p>DLedger Controller的部署有两种模式：</p><ul><li><p><strong>内嵌NameSrv</strong></p></li><li><p><strong>单独部署DLedger Controller</strong></p></li></ul><h3 id=3-dledger-controller部署>3. DLedger Controller部署</h3><p><code>DLedger Controller</code> 有两种模式，分别看一下这两种模式的部署。</p><h4 id=31-dledger-controller内嵌nameserver部署>3.1 DLedger Controller内嵌NameServer部署</h4><p><code>DLedger Controller</code> 以插件的模式内嵌到NameServer进行部署。部署的示意图如下：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/quickstart/Controller%20as%20plugin.png alt="Controller as plugin"></p><p>嵌入 NameServer 部署时只需要在 NameServer 的配置文件中设置 <strong><code>enableControllerInNamesrv=true</code></strong>，并填上 <strong><code>DLedger Controller</code></strong> 的配置即可。</p><pre><code class=language-properties data-lang=properties>enableControllerInNamesrv = true 
controllerDLegerGroup = group1
controllerDLegerPeers = n0-127.0.0.1:9877;n1-127.0.0.1:9878;n2-127.0.0.1:9879
controllerDLegerSelfId = n0
controllerStorePath = /home/admin/DledgerController
enableElectUncleanMaster = false
notifyBrokerRoleChanged = true
</code></pre><p>参数说明：</p><ul><li>enableControllerInNamesrv：Nameserver 中是否开启 controller，默认 false。</li><li>controllerDLegerGroup：DLedger Raft Group 的名字，同一个 DLedger Raft Group 保持一致即可。</li><li>controllerDLegerPeers：DLedger Group 内各节点的端口信息，同一个 Group 内的各个节点配置必须要保证一致。</li><li>controllerDLegerSelfId：节点 id，必须属于 controllerDLegerPeers 中的一个；同 Group 内各个节点要唯一。</li><li>controllerStorePath：controller 日志存储位置。controller 是有状态的，controller 重启或宕机需要依靠日志来恢复数据，该目录非常重要，不可以轻易删除。</li><li>enableElectUncleanMaster：是否可以从 SyncStateSet 以外选举 Master，若为 true，可能会选取数据落后的副本作为 Master 而丢失消息，默认为 false。</li><li>notifyBrokerRoleChanged：当 Broker 副本组上角色发生变化时是否主动通知，默认为 true。</li></ul><p>以上参数都是RocketMQ5.0新增的。</p><blockquote><p>Tips: enableControllerInNamesrv=true配置是内嵌NameServer的开关。如上配置需要配置3个 controllerDLegerSelfId需要做相应的修改n0、n1、n2</p></blockquote><p>使用NameServer的启动方式启动。</p><h4 id=32-dledger-controller独立部署>3.2 DLedger Controller独立部署</h4><p>独立部署示意图如下：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/quickstart/Controller%20deploy%20indepdent.png alt="Controller deploy indepdent"></p><p>独立部署的配置和内嵌配置的区别就是无需配置 <strong><code>enableControllerInNamesrv=true</code></strong> 。 具体配置可以参照内嵌部署的配置。启动可以使用如下命令：</p><p><strong>单例模式：</strong></p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ sh bin/mqcontroller -c conf/controller/controller-standalone.conf
</code></pre></div><p><strong>集群模式：</strong></p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ nohup bin/mqcontroller -c ./conf/controller/cluster-3n-independent/controller-n0.conf <span style=color:#000;font-weight:700>&amp;</span>
$ nohup bin/mqcontroller -c ./conf/controller/cluster-3n-independent/controller-n1.conf <span style=color:#000;font-weight:700>&amp;</span>
$ nohup bin/mqcontroller -c ./conf/controller/cluster-3n-independent/controller-n2.conf <span style=color:#000;font-weight:700>&amp;</span>
</code></pre></div><h4 id=33-快速启动dledger-controller>3.3 快速启动DLedger Controller</h4><p>在RocketMQ中提供了快速启动的脚本</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#8f5902;font-style:italic>#内嵌NameServer快速启动</span>
$ sh bin/controller/fast-try-namesrv-plugin.sh start

<span style=color:#8f5902;font-style:italic>#独立部署快速启动</span>
$ sh bin/controller/fast-try-independent-deployment.sh start
</code></pre></div><h3 id=4-broker-controller-dledger模式>4. Broker Controller DLedger模式</h3><p>Broker搭配Controller DLedger模式可以实现高可用以及主备自动切换。 Broker的部署和之前的版本相同只是增加了一些与Controller DLedger相关配置：</p><ul><li>enableControllerMode：Broker controller 模式的总开关，只有该值为 true，自动主从切换模式才会打开。默认为 false。</li><li>controllerAddr：controller 的地址，多个 controller 中间用分号隔开。例如<code>controllerAddr = 127.0.0.1:9877;127.0.0.1:9878;127.0.0.1:9879</code></li><li>syncBrokerMetadataPeriod：向 controller 同步 Broker 副本信息的时间间隔。默认 5000（5s）。</li><li>checkSyncStateSetPeriod：检查 SyncStateSet 的时间间隔，检查 SyncStateSet 可能会 shrink SyncState。默认5000（5s）。</li><li>syncControllerMetadataPeriod：同步 controller 元数据的时间间隔，主要是获取 active controller 的地址。默认10000（10s）。</li><li>haMaxTimeSlaveNotCatchup：表示 Slave 没有跟上 Master 的最大时间间隔，若在 SyncStateSet 中的 slave 超过该时间间隔会将其从 SyncStateSet 移除。默认为 15000（15s）。</li><li>storePathEpochFile：存储 epoch 文件的位置。epoch 文件非常重要，不可以随意删除。默认在 store 目录下。</li><li>allAckInSyncStateSet：若该值为 true，则一条消息需要复制到 SyncStateSet 中的每一个副本才会向客户端返回成功，可以保证消息不丢失。默认为 false。</li><li>syncFromLastFile：若 slave 是空盘启动，是否从最后一个文件进行复制。默认为 false。</li><li>asyncLearner：若该值为 true，则该副本不会进入 SyncStateSet，也就是不会被选举成 Master，而是一直作为一个 learner 副本进行异步复制。默认为false。</li><li>inSyncReplicas：需保持同步的副本组数量，默认为1，allAckInSyncStateSet=true 时该参数无效。</li><li>minInSyncReplicas：最小需保持同步的副本组数量，若 SyncStateSet 中副本个数小于 minInSyncReplicas 则 putMessage 直接返回 PutMessageStatus.IN_SYNC_REPLICAS_NOT_ENOUGH，默认为1。</li></ul><blockquote><p>Tips:</p><ul><li>Controller DLedger模式下enableControllerMode必须为true,默认为false</li><li>实现消息不丢失allAckInSyncStateSet设置为true</li></ul></blockquote><h3 id=5-总结>5. 总结</h3><ul><li>若需要保证Controller具备容错能力，Controller部署需要三副本及以上（遵循Raft的多数派协议）</li><li>Controller部署配置文件中配置参数<code>controllerDLegerPeers</code> 中的IP地址配置成其他节点能够访问的IP,在多机器部署的时候尤为重要。例子仅供参考需要根据实际情况进行修改调整。</li><li>要想实现消息不丢失需要Broker进行相对应的配置进行配合使用。</li></ul><blockquote><p>我是蚂蚁背大象，文章对你有帮助点赞关注我，文章有不正确的地方请您斧正留言评论~谢谢! 大家可以Follow我的<a href=https://github.com/mxsm><strong>GitHub mxsm</strong></a></p></blockquote><p>参考资料：</p><ul><li><a href=https://github.com/apache/rocketmq/wiki/RIP-44-Support-DLedger-Controller>https://github.com/apache/rocketmq/wiki/RIP-44-Support-DLedger-Controller</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-99e54084096a24c513ec816aec143554>2 - RocketMQ5.0 Store</h1></div><div class=td-content><h1 id=pg-183998bd110bc38c9f3589fe0b8f1b7c>2.1 - RocketMQ5.0-CommitLog设计与源码解析</h1><p>RocketMQ4.x设RocketMQ5.0在CommitLog的设计上面基本上没有太多调整，还是沿用了之前的设计。下面来对CommitLog的设计思想和源码进行分析。</p><h3 id=1-commitlog示意图>1. CommitLog示意图</h3><p>CommitLog是对RocketMQ的存储的抽象，示意图如下：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/CommitLog%E7%A4%BA%E6%84%8F%E5%9B%BE.png alt=CommitLog示意图></p><p><strong><code>CommitLog</code></strong> 主要由几部分组成：</p><ul><li><strong>MappedFileQueue：</strong> 主要用来操作相关数据存储文件。将一系列的MappedFile抽象成一个队列。</li><li><strong>FlushManager：</strong> 数据落地磁盘的管理，主要分为两类：实时数据刷盘(FlushRealTimeService),以及异步刷盘(GroupCommitService)</li><li><strong>FlushDiskWatcher：</strong> 刷盘观察者，处理队列中的刷盘请求，对于规定时间内没有刷盘成功的进行处理。</li></ul><blockquote><p>Tips: 多目录存储参照<a href=https://github.com/apache/rocketmq/wiki/RIP-7-Multiple-Directories-Storage-Support>RIP-7</a></p></blockquote><p><strong><code>CommitLog</code></strong> 底层主要是通过FileChannel来实现。其中还有一些RocketMQ的自身优化，例如： TransientStorePool。</p><h3 id=2-mappedfilequeue>2. MappedFileQueue</h3><p><strong><code>MappedFileQueue</code></strong> 是对数据存储文件的一个抽象，将多个数据文件抽象成为一个文件队列。通过这个文件队列对文件进行操作操作。同时保存一些 <strong><code>CommitLog</code></strong> 的属性。来看一下MappedFileQueue中的几个重要的属性：</p><ul><li><strong>storePath：</strong> 数据文件存储的位置</li><li><strong>mappedFileSize：</strong> 单个数据文件的大小</li><li><strong>mappedFiles：</strong> 数据文件列表</li><li><strong>allocateMappedFileService：</strong> 分配文件服务</li><li><strong><code>flushedWhere</code>： 当前刷盘指针，表示该指针之前所有的数据全部持久化到了硬盘上面</strong></li><li><strong><code>committedWhere</code> ：当前数据提交指针，内存中byteBuffer当前的写指针，该值大于等于flushedWhere</strong></li></ul><blockquote><p>Tips: 同步刷盘的过程中flushedWhere等于committedWhere</p></blockquote><p><strong><code>MappedFileQueue</code></strong> 同时提供了一些操作例如：</p><ul><li>刷新文件(更新flushedWhere) MappedFileQueue#flush</li><li>提交文件(更新committedWhere)MappedFileQueue#commit</li><li>以及一些文件的操作，获取最新文件和第一个文件等等。</li></ul><h4 id=21-mappedfile>2.1 MappedFile</h4><p><strong><code>MappedFile</code></strong> 是对文件的抽象，包含了对RocketMQ数据文件的整个操作。例如获取文件名称、文件大小、判断文件是否可用、是否已经满了等等的操作。</p><p>单个数据文件默认是 <strong>1G</strong> 。然后按照顺序存储Producer发送的消息。数据格式如下图所示：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/RocketMQ%20%E6%B6%88%E6%81%AF%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.png alt="RocketMQ 消息数据格式"></p><p>数据文件就是由上图所示的一条条的数据组成。通过观察你可能会发现存储Topic的长度只占用了一个字节。这个也是在使用RocketMQ需要注意的一点就是：</p><p><strong><code>由于只用了一个字节保存Topic的长度所以Topic的最大长度是127字符,如果使用中文长度会更短。</code></strong> 在RocketMQ5.0的版本中增加 <strong><code>PutMessageHook</code></strong> 会在Put Message之前去Check一些必要的数据和参数。例如Topic的长度就其中之一。具体可以参照 <strong><code>HookUtils</code></strong> 工具类。</p><h3 id=3-commitlog消息处理流程>3. CommitLog消息处理流程</h3><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/CommitLog%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png alt=CommitLog工作流程></p><h4 id=31-消息校验>3.1 消息校验</h4><p>生产者发送消息到 <strong><code>Broker Master</code></strong> 后，在存入 <strong><code>CommitLog</code></strong> 之前首先会经过一个 <strong><code>PutMessageHook</code></strong> 的处理接口类，这个有不同的实现，主要用于校验一些消息的数据如：Message Topic 大小、Message Body大小、以及MessageStore的一些状态等等。</p><blockquote><p>Tips: 通过实现PutMessageHook可以做到更多校验以及一些其他的事情。</p></blockquote><h4 id=32-消息处理>3.2 消息处理</h4><p><strong><code>CommitLog#asyncPutMessage</code></strong> 在CommitLog有两个分别用来处理单个消息和批量消息。下面以单个消息处理为例</p><ul><li><p><strong>消息的一些属性设置</strong></p><p>消息体的CRC、设置消息生产者的IP地址是否为IPV6、设置存储Broker IP地址是否为IPV6</p></li><li><p><strong>HA处理设置</strong></p><p>根据服务的设置判断是否需要处理HA. RocketMQ5.0 HA有两种模式：</p><ul><li><strong>Controller Model模式：</strong> DLedger模式的进阶版本，对原有的DLedger模式进行优化</li><li><strong>SlaveActingMaster模式</strong></li></ul><p>这两个模式主要目的是根据返回ACK的Slave数量来判断消息是否同步到Slave成功</p></li><li><p><strong>Append Message 到 MappedByteBuffer</strong></p></li><li><p><strong>处理Append的Result</strong></p></li><li><p><strong>根据Broker的配置进行刷盘</strong></p><p>刷盘是根据在启动Broker的时候配置的刷盘模式进行不同的刷盘策略。</p><ul><li><strong>SYNC_FLUSH：</strong> GroupCommitService线程进行实时刷盘</li><li><strong>ASYNC_FLUSH：</strong> FlushRealTimeService线程进行异步刷盘</li></ul></li><li><p><strong>处理HA</strong></p><p>HA的处理不是必须的，这个看RocketMQ是否配置了HA模式。只有配置了才需要进行处理。</p></li></ul><h3 id=4-刷盘解析>4. 刷盘解析</h3><p>刷盘主要有两种模式：同步刷盘和异步刷盘。刷盘主要由 <strong><code>FlushManager</code></strong> 进行管理。刷盘接口关系：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/%E5%88%B7%E7%9B%98%E6%8E%A5%E5%8F%A3%E5%85%B3%E7%B3%BB%E5%9B%BE.png alt=刷盘接口关系图></p><h4 id=41-同步刷盘解析>4.1 同步刷盘解析</h4><p>同步刷盘是由 <strong><code>GroupCommitService</code></strong> 来处理，同步刷盘的详细流程如下：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98%E7%9A%84%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B.png alt=同步刷盘的详细流程></p><p>在刷盘过程中使用到的两个类：<strong><code>GroupCommitService</code></strong> 和 <strong><code>FlushDiskWatcher</code></strong> 从本质上看都是一个Thread。</p><p>GroupCommitService处理主要分为三步：</p><ol><li><p>往链表中写入GroupCommitRequest请求</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/image-20220912140817889.png alt=image-20220912140817889></p></li><li><p>GroupCommitService执行doCommit方法</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/image-20220912140929356.png alt=image-20220912140929356></p></li><li><p>执行刷盘操作，将结果写入GroupCommitRequest</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/image-20220912141357835.png alt=image-20220912141357835></p></li></ol><p>到这里就已经基本上完成整个同步的刷盘步骤。细心的可能会发现还有一个 <strong><code>FlushDiskWatcher</code></strong> 这个类。它的功能主要是：处理在规定时间内还没有刷盘成功的请求。</p><h4 id=42-异步刷盘解析>4.2 异步刷盘解析</h4><p>异步刷盘的服务是**<code>FlushRealTimeService</code>** ，不过当内存缓存池 **<code>TransientStorePool</code>** 可用时，消息会先提交到TransientStorePool中的WriteBuffer内部，再提交到MappedFile的FileChannel中，此时异步刷盘服务就是CommitRealTimeService。下面看一下 **FlushRealTimeService** ：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/image-20220912145045587.png alt=image-20220912145045587></p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/image-20220912145109156.png alt=image-20220912145109156></p><p>而在启用了暂存池的情况下使用的是 <strong><code>CommitRealTimeService</code></strong> 进行刷盘：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/image-20220912151020859.png alt=image-20220912151020859></p><h3 id=5-总结>5. 总结</h3><ul><li>CommitLog在RocketMQ中充当一个存储的抽象，所有的存储操作都是通过CommitLog对外暴露。底层包含了很多其他组件来支持</li><li>刷盘的模式可以通过配置文件的 <strong>flushDiskType</strong> 字段来配置，SYNC_FLUSH表示同步刷盘、ASYNC_FLUSH表示异步刷盘</li><li>刷盘的服务主要是由三个服务：FlushRealTimeService、GroupCommitService、CommitRealTimeService来实现刷盘，以及FlushDiskWatcher来处理一些特殊的刷盘情况。这些服务本质上都是线程。</li></ul><blockquote><p>我是蚂蚁背大象，文章对你有帮助点赞关注我，文章有不正确的地方请您斧正留言评论~谢谢</p></blockquote><p>参考资料：</p><ul><li><a href=https://github.com/apache/rocketmq/wiki/RIP-7-Multiple-Directories-Storage-Support>https://github.com/apache/rocketmq/wiki/RIP-7-Multiple-Directories-Storage-Support</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-90b8826930eefcca2856d10acd2892bc>2.2 - RocketMQ5.0源码分析-AutoSwitchHAClient</h1><p>在RocketMQ5.0的HA模式中，<code>AutoSwitchHAClient</code> 是一个重要的组件，主要作用Broker Slave中用来处理Broker Master发来的CommitLog数据。RocketMQ5.0对<code>AutoSwitchHAClient</code>进行了增强来适应RocketMQ5.0的DLedger Controller的模式。</p><blockquote><p>Tips: RocketMQ版本：5.0.0</p></blockquote><h2 id=1-rocketmq4x和rocketmq50版本协议对比>1. RocketMQ4.x和RocketMQ5.0版本协议对比</h2><p>在RocketMQ4.x版本中只有一个CommitLog数据传输的协议，而RocketMQ5.0为了适配DLedger Controller的模式增加了新的握手和连接协议以及对原有的CommitLog传输协议进行了增强。</p><ul><li><strong>HANDSHAKE(新增协议)</strong></li><li><strong>TRANSFER(对4.x版本进行了增强)</strong></li></ul><h3 id=11-handshake协议>1.1 HANDSHAKE协议</h3><p><strong>Slave发送给Master协议格式：</strong></p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/Handshake%20header.png alt="Handshake header"></p><p><strong>作用：将Slave的状态告诉Master。</strong></p><p>这个协议是RocketMQ5.0新增的协议。</p><blockquote><p>Tips: 在Broker Slave给Broker Master发了HANDSHAKE后，Broker Master处理完成后会给Broker Slave回一个ACK</p></blockquote><p><strong>Master给Slave回复的ACK协议格式：</strong></p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/Master%20Handshare%20Message%20ACK.png alt="Master Handshare Message ACK"></p><p><strong>作用：用于对齐Slave和Master的数据</strong></p><h3 id=12-transfer协议>1.2 TRANSFER协议</h3><p><strong>RocketMQ4.x协议格式：</strong></p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/transfer%20protocol.png alt="transfer protocol"></p><p>分为头部和数据两大部分，头部包含了offSet和数据大小</p><p><strong>RocketMQ5.0协议格式：</strong></p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/Transfer%20Message.png alt="Transfer Message"></p><p>由于是RocketMQ4.x的协议增强，除了包含offSet和数据大小以外还包含了DLedger Controller模式的一些Broker的元数据信息。</p><h2 id=2-rocketmq50-autoswitchhaclient处理流程>2. RocketMQ5.0 AutoSwitchHAClient处理流程</h2><p><strong><code>AutoSwitchHAClient</code></strong> 处理流程示意图如下：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/AutoSwitchHAClient%20Handle%20flow.png alt="AutoSwitchHAClient Handle flow"></p><blockquote><p>Tips: 从源码可以知道AutoSwitchHAClient继承了ServiceThread，所以本质上AutoSwitchHAClient是一个线程。线程的循环执行来处理Master Broker发送过来的CommitLog。</p></blockquote><p><code>AutoSwitchHAClient</code> 主要通过不同的状态来控制不同的流程：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/AutoSwitchHAClient-status-change.png alt=AutoSwitchHAClient-status-change></p><p><strong>状态有以下几种：</strong></p><ul><li><strong>SHUTDOWN</strong></li><li><strong>READY</strong></li><li><strong>HANDSHAKE</strong></li><li><strong>TRANSFER</strong></li><li><strong>SUSPEND(暂时没用到)</strong></li></ul><p>AutoSwitchHAClient主要是Broker Slave用来处理Broker Master发送的数据，以及Broker Slave自身的一些内部</p><h3 id=21-ready>2.1 READY</h3><p><strong><code>READY</code></strong> 状态也是初始化状态，当AutoSwitchHAClient被初始化，AutoSwitchHAClient的状态会被设置为READY状态。在READY状态下主要做两件事：</p><ul><li><strong>Truncate Invalid message(截断无效的message)</strong></li><li><strong>Connect Broker Master（与Master建立TCP链接）</strong></li></ul><p>接下来我们就来分析这两种情况。</p><h4 id=211-truncate-invalid-message截断无效的message>2.1.1 Truncate Invalid message(截断无效的message)</h4><p>什么情况下需要进行消息进行截断？当Broker分发的数据存在落后的情况也就是从Producer生成的消息发送到Broker后还存在有没有dispatch的数据这种情况下可能需要进行消息截断。然后对未dispatch的消息数据进行预处理校验。然后将预处理完成后的值后面的日志进行截断(也有可能不存在，这里是处理无效数据)</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221012214111881.png alt=image-20221012214111881></p><p><strong>通过分析代码发现 AutoSwitchHAClient READY 状态下截断本质上是做的处理Slave Broker的无效日志和消费者队列的数据。也就是首先对齐自身的数据这里包括：CommitLog和Consumer Queue</strong></p><h4 id=211--connect-broker-master与master建立tcp链接>2.1.1 Connect Broker Master（与Master建立TCP链接）</h4><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221012215935051.png alt=image-20221012215935051></p><p>如果与Broker Master建立了TCP连接，然后会将状态设置为**<code>HANDSHAKE</code>**</p><h3 id=22-handshake>2.2 HANDSHAKE</h3><p>AutoSwitchHAClient在HANDSHAKE状态下会发送握手信息给Master，信息格式如下：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/Handshake%20header.png alt="Handshake header"></p><p>也就是上文提到的HANDSHAKE协议数据。这里包括：</p><ul><li><strong>Slave的状态</strong></li><li>同步开始的文件位置，以及是否为Learner角色</li><li>slave的地址(通过长度来判断是否为IPV4还是IPV6)</li></ul><p>在Master收到Slave的发送的HANDSHAKE数据后会对数据进行处理：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221012221841662.png alt=image-20221012221841662></p><p>主要是将Slave的状态数据以及角色和IP地址记录到Master，同时master会构建一个HANDSHAKE的ACK给到Slave。那么Master给Slave返回的数据HANDSHAKE ACK数据格式：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/Master%20Handshare%20Message%20ACK.png alt="Master Handshare Message ACK"></p><p>Master给Slave回的ACK包含了Master的一些元数据信息。源码代码构建如下：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221016094054892.png alt=image-20221016094054892></p><blockquote><p>Tips: 在5.0.0的代码中为了和发送日志数据的头统一，Master在给Slave回复 HANDSHAKE ACK状态的时候请求头也增加了EpochStartOffset和Additional info 字段。设置为0，为了减少数据传输笔者进行了优化去除了这两个字段传输具体可以参照 <a href=https://github.com/apache/rocketmq/issues/5157>ISSUE#5157</a> 对应的PR，社区已经approved等待代码合并。这个优化主要是处于两个考虑：</p><ul><li>和文档中的设计统一</li><li>减少传输过程中的数据传输</li></ul></blockquote><p>Slave收到Master的HANDSHAKE ACK后获取数据</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221016103311015.png alt=image-20221016103311015></p><p><strong>主要是作用是Slave和Master对齐数据</strong></p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221016103809712.png alt=image-20221016103809712></p><p>到这里为止就完成整个传输数据的前期准备工作。</p><blockquote><p>总结：前期的准备工作主要做了两件事情</p><ul><li>Slave自身的数据对齐，删除一些无效的数据(如果有的情况下)，这些无效的数据包括日志数据、cq数据</li><li>Slave和Master的数据对齐，当Slave的数据在Master前面的时候也就是数据多于Master，此时会对数据进行删除。与此同时会对齐</li></ul></blockquote><h3 id=23-transfer>2.3 TRANSFER</h3><p>Slave AutoSwitchHAClient状态变成TRANSFER后就开始处理Master的发送过来的日志数据，处理完成后报告Slave的maxOffSet。</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221016121849931.png alt=image-20221016121849931></p><blockquote><p>Tips: 日志数据传输不能跨Epoch传输。</p></blockquote><h2 id=3-协议优化思考>3. 协议优化思考</h2><h3 id=31-handshake协议优化>3.1 HANDSHAKE协议优化</h3><p><strong>Slave发送给Master协议格式优化:</strong></p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/Handshake%20header.png alt="Handshake header"></p><p>协议可以发现，用了4个字节来表示状态。这里的设计是和枚举的int类型进行了对应，其实我们可以用1btye来表示。地位到高位每一个bit表示状态，例如地位第一位1表示READY状态。同时Flags也可以进行优化用同样的1byte就可以表示状态。这样8byte的数据用2个byte就可以表示。</p><p><strong>Master发送给Slave的协议格式优化：</strong></p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/Master%20Handshare%20Message%20ACK.png alt="Master Handshare Message ACK"></p><p>这个优化同样也是优化state字段，优化的思路和上面的一致。</p><h3 id=32-transfer协议优化>3.2 TRANSFER协议优化</h3><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/Transfer%20Message.png alt="Transfer Message"></p><p>这个优化同样也是优化state字段，优化的思路和上面的一致。</p><blockquote><p>Tips: 后续笔者会在社区创建ISSUE进行社区讨论然后确定是否进行协议优化，如果确定进行协议优化提交对应的PR</p></blockquote><h2 id=4-总结>4. 总结</h2><p>AutoSwitchHAClient作为RocketMQ5.0高可用的重要一个主键，其功能主要是Slave Broker和Master进行通讯同时处理来自Master传输的日志数据。搭配其他的组件使用来确保DLedger Controller模式下的自主切换和RocketMQ的高可用。后续会有文章接着分析其他DLedger Controller模式高可用的其他组件。</p><blockquote><p>我是蚂蚁背大象(GitHub:mxsm)，文章对你有帮助点赞关注我，文章有不正确的地方请您斧正留言评论~谢谢!</p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-39b03f14225919dbe9d2ceb73847296b>2.3 - RocketMQ5.0源码解析-CommitLog设计与几个重要的属性关系图文解析</h1><p>如果把RocketMQ看做应用系统CommitLog就相当于应用的系统中的存储层也就是数据库的功能。下面就来聊一聊CommitLog的设计以及CommitLog包含的组件中的一些重要属性字段wrotePosition、committedPosition、flushedPosition、fileFromOffset、flushedWhere、committedWhere之间的关系。</p><h2 id=1commitlog的组成>1.CommitLog的组成</h2><p><code>CommitLog</code> 是MQ对存储层的抽象，整体的架构设计如下：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/CommitLog%20architecture.png alt="CommitLog architecture"></p><p>从上图可以看出来整个分为了三层：</p><ul><li><p><strong>MappedFile</strong></p><p>作为底层的数据存储，默认情况下单个文件大小1G。MappedFile提供了一些对文件元数据以及可用性的一些操作以及添加消息数据到文件中的接口。</p></li><li><p><strong>MappedFileQueue</strong></p><p>讲底层的单个数据文件以队列的形式组织起来，主要提供获取单个MappedFile的一些操作。例如：获取第一个或者最后一个数据文件，以及文件属性的相关操作都是由<strong>MappedFileQueue</strong> 提供。</p></li><li><p><strong>CommitLog</strong></p><p>整个对外提供服务的封装，同时一些数据刷盘操作都是在CommitLog中实现的。</p></li></ul><p>MappedFile文件列表组成了MappedFileQueue，然后通过增加相关的对外操作于MappedFileQueue组成了CommitLog。</p><h2 id=2-组件重要位置属性说明>2. 组件重要位置属性说明</h2><p>在<strong>CommitLog、MappedFileQueue、MappedFile</strong> 这三个组件中都有几个重要的属性，来标记日志的waterline,如下图：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/CommitLog%20attribute%20relation.png alt="CommitLog attribute relation"></p><p>下面来一一分析不同情况下这些属性之间的关系，在RocketMQ中很多地方都有用到这些waterline的关系特别是在处理日志恢复以及HA的时候有用到。</p><h3 id=21-mappedfile-waterline-说明>2.1 MappedFile waterline 说明</h3><p>在MappedFile的默认实现中有如下的几个属性：</p><ul><li><strong>wrotePosition</strong></li><li><strong>committedPosition</strong></li><li><strong>flushedPosition</strong></li><li><strong>fileFromOffset</strong></li></ul><p>这几个属性指向的文件的位置决定了日志的数据是否丢失和新增的日志应该从哪个位置写入。下面会根据不同的情况来进行分析</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/MappedFile%20Waterline.png alt="MappedFile Waterline"></p><p>上图说明上述四个变量之间的关系</p><blockquote><p>Tips: 上述图是从生产者的角度来看的，也就是生产者收到Broker的确认ACK。</p></blockquote><p><strong>字段说明：</strong></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>wrotePosition</td><td>初始化值0，当有消息append的时候wrotePosition会增加，一个消息发送到Broker,wrotePosition指针就会往前移动</td></tr><tr><td>committedPosition</td><td>初始化值0，表示从TransientStorePool中Commit了多少数据到File Channel中的指针，当暂存池为空的时候使用的是wrotePosition</td></tr><tr><td>flushedPosition</td><td>初始值为0，flushedPosition指针表示的是已经落盘的持久化数据。这个指针之前的数据表示已经落盘就算服务异常退出只要不删除本地文件就不会丢失</td></tr><tr><td>fileFromOffset</td><td>数据文件的开始值，也就是数据文件的名称。例如：文件大小默认为1G的来说，那么第二个文件的fileFromOffset=1024 * 1024 * 1024,文件创建该值的大小就不会变</td></tr></tbody></table><p><strong>大小关系：wrotePosition >= committedPosition >= flushedPosition >= fileFromOffset</strong></p><h3 id=22-mappedfilequeue-waterline说明>2.2 MappedFileQueue waterline说明</h3><p>在MappedFileQueue存在这样的两个属性：</p><ul><li><strong>flushedWhere</strong></li><li><strong>committedWhere</strong></li></ul><p>看到这两个属性你会发现和MappedFile中的两个属性committedPosition和flushedPosition属性比较相似。通过下图看一下两者之间的关系：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/MappedFileQueue%E5%AD%97%E6%AE%B5%E5%85%B3%E7%B3%BB.png alt=MappedFileQueue字段关系></p><p><strong>flushedWhere</strong> 、<strong>committedWhere</strong> 这两个字段主要是从MappedFileQueue的角度去看的。从源码进行分析：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/image-20221015161021289.png alt=image-20221015161021289></p><p><strong>committedWhere：</strong> 当前MappedFile的fileFromOffset + 当前MappedFile的committedPosition</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/image-20221015161105559.png alt=image-20221015161105559></p><p><strong>flushedWhere ：</strong> 当前MappedFile的fileFromOffset + 当前MappedFile的flushedPosition</p><h3 id=23-commitlog>2.3 CommitLog</h3><p>CommitLog主要是提供对外的接口服务，这里包括：</p><ul><li>消息的插入操作</li><li>消息的刷盘任务(同步和异步)</li><li>暂存池的数据提交到FileChannel中的任务</li></ul><h2 id=3-commitlog消息处理流程>3. CommitLog消息处理流程</h2><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/store/commitlog/CommitLog%20handle%20message%20flow.png alt="CommitLog handle message flow"></p><p>CommitLog启动后同时会启动相对应的线程来处理Commit和Flush Disk。</p><ul><li><strong>FlushManager处理Commit指针和Flush Disk指针的推进</strong></li><li><strong>MappedFile#appendMessage处理writePosition指针</strong></li></ul><p>Producer发送消息给Broker后，首先就是推动wrotePosition往前(不管是使用FileChannel还是暂存池)，然后根据配置的是否启用暂存池来确定是否需要CommitRealTimeService线程池去处理将暂存池的数据提交到FileChannel中，这个会推动committedPosition指针往前移动。然后就是根据刷盘策略是异步刷盘还是同步刷盘来启动不同的线程去处理刷盘来推动MappedFile和MappedFileQueue 提交相关的指针往前。</p><h2 id=4-总结>4. 总结</h2><p><strong>MappedFile字段：</strong></p><ul><li>fileFromOffset其实就是日志数据存储文件的名称，初始值为0，每增加增加一个文件默认情况下增加1024 * 1024 * 1024</li><li>wrotePosition表示写入FileChannel的数据，这些数据可能还存在内存中不应落盘。每次增加日志wrotePosition就会往后移动</li><li>committedPosition在暂存池启动的时候才会使用到，暂存池提价的FileChannel中的数据位置，这个字段只有启用了暂存池才会用到，要不然就是使用的wrotePosition</li><li>flushedPosition表示就落盘的位置，在小于flushedPosition位置的数据都已经持久化到了磁盘</li></ul><p>**MappedFileQueue字段: **</p><ul><li>flushedWhere整个文件队列的刷盘的位置，异步刷盘由 <code>FlushRealTimeService</code> 线程处理，同步刷盘由 <code>GroupCommitService</code> 处理</li><li>committedWhere暂存池的提交位置，由CommitRealTimeService线程处理</li></ul><blockquote><p>我是蚂蚁背大象(GitHub:mxsm)，文章对你有帮助点赞关注我，文章有不正确的地方请您斧正留言评论~谢谢!</p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-bae99819ba415c77ab3209bbe2a910b4>3 - RocketMQ5.0主备自动切换模式Broker选主详解</h1><p>RocketMQ5.0增加了主备自动切换模式，这个模式是基于新开发的模块DLedger Controller(基于Raft组件<a href=https://github.com/openmessaging/dledger>DLedger</a>)。下面结合源码来分析一下RocketMQ主备自动切换模式下的选主的流程。</p><blockquote><p>Tips: RocketMQ源码版本：5.0.0</p></blockquote><h2 id=1-何时选主broker>1. 何时选主Broker</h2><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/Broker%20Elect%20Master.png alt="Broker Elect Master"></p><p>Broker的选主发起主要有三种情况：</p><ul><li><p>通过admin命令人为主动发起重新选主</p><p>命令发起具体参照 <strong><code>electMaster</code></strong> 命令(运维命令由笔者开发完成)，详细使用参照命令的说明</p></li><li><p>RocketMQ集群刚搭建Broker启动注册Broker到DLedger Controller，DLedger Controller还没有选主，然后触发选主操作。</p></li><li><p>RocketMQ Broker Master下线或者因为其他情况不能正常提供服务与DLedger Controller服务不能正常连接或者心跳失效，会触发DLedger Controller选主Broker</p></li></ul><h2 id=2-如何选主broker>2. 如何选主Broker</h2><p>文章上面有提到触发选主的三种情况，下面我们就把这三种情况一一进行分析</p><h3 id=21-broker启动注册触发选主>2.1 Broker启动注册触发选主</h3><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/Broker%20Master%20elect%20process.png alt="Broker Master elect process"></p><p>主备自主切换模式下Broker启动时候到底是Master还是Slave需要通过DLedger Controller服务通过选主的方式来确定。</p><p><strong>Broker启动注册到DLedger Controller</strong></p><p>Broker启动后，将Broker的元数据：</p><ul><li>clusterName</li><li>brokerName</li><li>address</li><li>epoch</li><li>maxOffset</li></ul><p>注册到DLedger Controller,由 <strong><code>BrokerOuterAPI#registerBrokerToController</code></strong> 提供注册的服务：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221019180858462.png alt=image-20221019180858462></p><p><strong>DLedger Controller触发选主</strong></p><p><strong>DLedger Controller</strong> 模块的主要逻辑在ReplicasInfoManager中。当DLedger Controller接收到Broker发送的 <strong><code>CONTROLLER_REGISTER_BROKER</code></strong> 消息后就处理选主，由ReplicasInfoManager#registerBroker处理逻辑：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221019182903186.png alt=image-20221019182903186></p><p><strong>Broker Change Role</strong></p><p>Broker注册后收到DLedger Controller返回的数据，根据返回数据的Master Address和Broker的IP进行对比来判断当前Broker是设置为Master还是Slave。</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221019190349777.png alt=image-20221019190349777></p><p>到这里就实现了Broker的选主。</p><h3 id=22-broker-master-inactive触发选主>2.2 Broker Master Inactive触发选主</h3><p>Broker Master下线或者Broker Master和DLedger Controller心跳失效触发选主，DLedger Controller有一个定时任务执行 <code>DefaultBrokerHeartbeatManager#scanNotActiveBroker</code> ：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221019191416688.png alt=image-20221019191416688></p><p>通知最终会触发 <code>ControllerManager#onBrokerInactive</code> 方法：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221019191744705.png alt=image-20221019191744705></p><p><strong><code>ReplicasInfoManager#electMaster</code></strong> 负责选主：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221019195612264.png alt=image-20221019195612264></p><blockquote><p>Tips: 笔者领了一个开发一个Preferred Master 的功能任务，可以优先选择某个 Broker 作为 master。还在代码研究和设计阶段。后续会提交PR</p></blockquote><p><strong>参与选主的Broker是从SyncStateSet选取的。</strong></p><p>然后选举的结果通知Broker, <strong><code>AdminBrokerProcessor#notifyBrokerRoleChanged</code></strong> 处理改变：</p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221019200415384.png alt=image-20221019200415384></p><p><img src=https://raw.githubusercontent.com/mxsm/picture/main/rocketmq5/broker/ha/image-20221019200445279.png alt=image-20221019200445279></p><h3 id=23-admin命令触发选主>2.3 Admin命令触发选主</h3><p>首先看一下命令的说明：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>usage: mqadmin electMaster -a &lt;arg&gt; -b &lt;arg&gt; -c &lt;arg&gt; <span style=color:#ce5c00;font-weight:700>[</span>-h<span style=color:#ce5c00;font-weight:700>]</span> -n &lt;arg&gt;
 -a,--controllerAddress &lt;arg&gt;   The address of controller
 -b,--brokerAddress &lt;arg&gt;       The address of the broker which requires to become master
 -c,--clusterName &lt;arg&gt;         the clusterName of broker
 -h,--help                      Print <span style=color:#204a87>help</span>
 -n,--brokerName &lt;arg&gt;          The broker name of the replicas that require to be manipulated
</code></pre></div><p>指定一个Broker作为Master。后端DLedger Controller的实现也是通过 <strong><code>ReplicasInfoManager#electMaster</code></strong> 实现。</p><p>对于代码的详细细节大家可以去研究一下RocketMQ5.0的代码细节，以及DLedger相关的代码。</p><h2 id=3-总结>3. 总结</h2><p>Master ID由DLedger Controller设置，Slave的ID也是。选举发起方可能是由Broker发起或者由DLedger Controller发起，也有可能手动通过 **<code>Admin electMaster</code>**命令发起。Broker主备自主切换的主要依赖DLedger Controller。</p><blockquote><p>我是蚂蚁背大象(GitHub:mxsm)，文章对你有帮助点赞关注我，文章有不正确的地方请您斧正留言评论~谢谢!</p></blockquote></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank rel="noopener noreferrer" href=https://groups.google.com/u/1/g/ljbmxsm><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=个人掘金主页 aria-label=个人掘金主页><a class=text-white target=_blank rel="noopener noreferrer" href=https://juejin.cn/user/1151943918492855><i class="fab fa-twitter"></i></a></li></ul></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/mxsm><i class="fab fa-github"></i></a></li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2022 The Docsy Authors All Rights Reserved</small>
<small class=ml-1><a href=https://policies.google.com/privacy target=_blank>隐私政策</a></small><p class=mt-2><a href=/about/>Home</a></p></div></div></div></footer><div><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><script>$("p img").wrap(function(){return'<a data-fancybox="gallery" href="'+$(this).attr('src')+'"></a>'})</script></div></div><script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.8.1/dist/mermaid.min.js integrity=sha384-to2w0I1OqmbJ9J6yTnIX+KYU8grNpZoD1dKPLjgEJvMe5L5+/7qvuNa2sQo8WAWj crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js integrity="sha512-tBzZQxySO5q5lqwLWfu8Q+o4VkTcRGOeQGVQ0ueJga4A1RKuzmAu5HXDOXLEjpbKyV7ow9ympVoa6wZLEzRzDg==" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.15.0/flowchart.min.js integrity="sha512-6QsSiIybtf8tuZ6xfjRTr2tdtw3Gp4q5RSCh2b6q9seoKEQmhAG1RrCA8F0kXTwivVxRVbp/YF3zOh8rvEAU7Q==" crossorigin=anonymous></script><script src=/js/main.min.b541b310f01941a0abfd76b652b5fb60dac470573775bb5b31ff08fe3f6cea51.js integrity="sha256-tUGzEPAZQaCr/Xa2UrX7YNrEcFc3dbtbMf8I/j9s6lE=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/docsearch.js@2.6.3/dist/cdn/docsearch.min.js></script><script type=text/javascript>docsearch({appId:'JO2SY3WDAC',apiKey:'324ddb3b679c1308e5aa8bf222e07f8b',indexName:'mxsm',inputSelector:'.td-search-input',debug:!1})</script></body></html>