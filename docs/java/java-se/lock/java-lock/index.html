<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-java/java-se/lock/java-lock">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">Java中的那些锁事-1 | mxsm(蚂蚁背大象)</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://blog.ljbmxsm.com/docs/java/java-se/lock/java-lock"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java中的那些锁事-1 | mxsm(蚂蚁背大象)"><meta data-rh="true" name="description" content="1. 锁的特性"><meta data-rh="true" property="og:description" content="1. 锁的特性"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://blog.ljbmxsm.com/docs/java/java-se/lock/java-lock"><link data-rh="true" rel="alternate" href="https://blog.ljbmxsm.com/docs/java/java-se/lock/java-lock" hreflang="en"><link data-rh="true" rel="alternate" href="https://blog.ljbmxsm.com/docs/java/java-se/lock/java-lock" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="mxsm(蚂蚁背大象) RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="mxsm(蚂蚁背大象) Atom Feed">




<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-141789564-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-226F0LR9KE"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-226F0LR9KE",{anonymize_ip:!0})</script><link rel="stylesheet" href="/assets/css/styles.81eae2d7.css">
<link rel="preload" href="/assets/js/runtime~main.03db58b2.js" as="script">
<link rel="preload" href="/assets/js/main.7a1c57b2.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><div class="announcementBar_mb4j" role="banner"><div class="announcementBarPlaceholder_vyr4"></div><div class="content_knG7 announcementBarContent_xLdY">⭐️ If you like, give it a star on <a target="_blank" rel="noopener noreferrer" href="https://github.com/mxsm/mxsm-website">GitHub</a> and follow me. This web site is updating!! </div><button type="button" aria-label="Close" class="clean-btn close closeButton_CVFx announcementBarClose_gvF7"><svg viewBox="0 0 15 15" width="14" height="14"><g stroke="currentColor" stroke-width="3.1"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate"></b></a><a class="navbar__item navbar__link" href="/docs/intro">Tutorial</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">RocketMQ</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/rocketmq/rocketmq5">RocketMQ 5.0</a></li><li><a class="dropdown__link" href="/docs/rocketmq/rocketmq4">RocketMQ 4.X</a></li><li><a href="https://github.com/apache/rocketmq" target="_blank" class="dropdown__link">RocketMQ GitHub<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://rocketmq.apache.org/" target="_blank" class="dropdown__link">RocketMQ official website<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Spring</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/spring/spring-framework">Spring Framework</a></li><li><a class="dropdown__link" href="/docs/spring/spring-boot">Spring Boot</a></li><li><a class="dropdown__link" href="/docs/spring/spring-cloud">Spring Cloud</a></li><li><a href="https://spring.io/" target="_blank" class="dropdown__link">Spring official website<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Java</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/java/java-se">Java SE</a></li><li><a class="dropdown__link" href="/docs/java/java-web">Java Web</a></li><li><a class="dropdown__link" href="/docs/java/java-tools">Java Tools</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Middleware</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/netty/">Netty</a></li><li><a class="dropdown__link" href="/docs/redis">Redis</a></li><li><a class="dropdown__link" href="/docs/intro">Kafka-改造中</a></li><li><a class="dropdown__link" href="/docs/intro">Etcd-改造中</a></li><li><a class="dropdown__link" href="/docs/docker">Docker</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Database</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/intro">SQL-改造中</a></li><li><a class="dropdown__link" href="/docs/intro">MySQL-改造中</a></li><li><a class="dropdown__link" href="/docs/intro">PostgreSQL-改造中</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Theory</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/intro">SQL</a></li><li><a class="dropdown__link" href="/docs/intro">MySQL</a></li><li><a class="dropdown__link" href="/docs/intro">PostgreSQL</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Others</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/others/blog-building">Blog building</a></li><li><a class="dropdown__link" href="/docs/others/tools">Develop Tools</a></li><li><a class="dropdown__link" href="/docs/intro">PostgreSQL</a></li></ul></div><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/mxsm" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG menuWithAnnouncementBar_GW3s"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/java/java-se">Overview</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/java/java-se/JVM/Java-object-header">JVM</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/Java-object-header">深入理解Java对象头Mark Word</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/class-loader">类的加载</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/java-gc-log">Java GC日志图解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/java-must-know-command">Linux下Java开发者必须知道的那些Java命令</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/java-object-size">一个Java对象占用多大内存</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/java-ref">Java中的引用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/jvm-common-command">JVM常用的命令</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/jvm-gc">JVM垃圾收集器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/jvm-memory-model">JVM的内存模型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/jvm-paramters">JVM参数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/parental-delegate-model">类加载器和双亲委派模型</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/java/java-se/lock/distributed-lock">Lock</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/lock/distributed-lock">分布式锁</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/java/java-se/lock/java-lock">Java中的那些锁事-1</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/lock/synchronized">Java中的琐事-synchronized</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/java/java-se/concurrencemultithreading/AQS">Thread</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/AQS">AQS源码解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/AtomicXxxFieldUpdater">AtomicXXXFieldUpdater在内存优化中的是实战</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/CompletableFuture">CompletableFuture详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/JUC-atomic-class">JUC包中的原子类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/LockSupport">LockSupport用法和原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/ThreadLocal-source-analysis">ThreadLocal源码解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/callable-and-runnable">Callable与Runnable的区别你知道吗？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/java-concurrency-three-concept">Java并发编程中的三个概念</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/not-suggest-use-exectors">为什么不建议使用Executors创建线程池？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/queue">Java队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/thread-common-method">Thread的常用方法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool-handler-exception">线程池异常你都了解如何处理吗？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool-how-to-chosice">threadpool-how-to-chosice</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool-must-shutdown">揭秘为什么主线程结束了Java线程池还在运行</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool-thread-notice">线程池的线程的类型你是否了解？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool-thread-number-practice">线程池的数量和线程池中线程数量如何设置-实践篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool-thread-number">线程池的数量和线程池中线程数量如何设置-理论篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool">线程池源码解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadstate">线程的状态</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/java/java-se/javaio/BIO-NIO-AIO">IO</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/javaio/BIO-NIO-AIO">BIO NIO AIO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/javaio/io-explain">IO详解--分类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/javaio/java-nio-base">Java NIO 知识梳理和例子</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/javaio/nio-bytebuffer">Java NIO ByteBuffer使用图文详解</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/java/java-se/jdksourcereading/collection/ArrayList">Source Code Analysis</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/java/java-se/jdksourcereading/collection/ArrayList">collection</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/java/java-se/jdksourcereading/map/EnumMap">map</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/java/java-se/others/String StringBuffer StringBuilder">Others</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/String StringBuffer StringBuilder">String StringBuffer StringBuilder</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/async-profiler">Java 性能分析工具 async-profiler</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/bean-validation">如何自定义Bean validation实现数据校验</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/common-jdk-command">JVM常用的命令-JDK8</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/dynamic-static">动态代理与静态代理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/interface-abstract-class">接口抽象类的抉择</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/java-application-get-pid">Java程序中获取当前进程的进程ID(Pid)</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/java-modifier">Java修饰符</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/java-operator">Java操作符</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/java-sharp-design">Java源码简单吊炸天的设计</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/java-threadpool-experience">SpringBoot项目中线程池在服务类方法中创建后导致线程数量暴增</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/mapstruct">Spring BeanUtils从精通到放弃，Mapstruct从入门到精通</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/operators">业务开发中巧妙运用位运算</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/show-thread-use-cpu">查看线程的CPU使用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/string-concat">字符串拼接那些事</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/threadpool-used-error">Java线程池使用不当会发生什么-生产案例</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/volatile">volatile详解</a></li></ul></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Lock</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java中的那些锁事-1</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java中的那些锁事-1</h1></header><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-锁的特性">1. 锁的特性<a class="hash-link" href="#1-锁的特性" title="Direct link to heading">​</a></h3><ul><li>互斥</li><li>可见性</li></ul><p>锁作为并发共享数据，保证一致性的工具</p><p>锁的分类目录：</p><p><img loading="lazy" src="https://raw.githubusercontent.com/mxsm/document/master/image/JSE/Java%E7%9A%84%E4%B8%BB%E6%B5%81%E9%94%81.png" alt="图片" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-悲观锁--vs-乐观锁">2. 悲观锁  VS 乐观锁<a class="hash-link" href="#2-悲观锁--vs-乐观锁" title="Direct link to heading">​</a></h3><p><strong>悲观锁</strong>和<strong>乐观锁</strong>体现了看待线程同步的不同角度。在Java和数据库中都有应用</p><ul><li><strong>悲观锁</strong>：对于共享数据的并发操作，悲观锁认为自己在使用数据的时候一定会有其他的线程来修改数据。因此在获取数据的时候先加锁，确保数据不会被别的线程修改。Java中synchronized关键字和Lock的实现都是悲观锁。</li><li><strong>乐观锁</strong>：对于共享的数据，乐观锁认为自己的使用的数据不会有其他的线程修改，所以在获取数据的时候不会加锁。只是在更新的时候去判断有没有别的线程更新了这个数据。如果这个数据没有被更新，当前的线程奖自己修改的数据成功写入。如果数据已经被其他的的线程更新了根据不同的实现方式执行不同的操作（报错或者重试）。乐观锁在Java中使用的是无锁编程来实现的(CAS算法)</li></ul><p><img loading="lazy" src="https://raw.githubusercontent.com/mxsm/document/master/image/JSE/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E6%89%A7%E8%A1%8C%E5%9B%BE%E8%A7%A3.png" alt="图解" class="img_ev3q"></p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点使其读操作性能大大提高。</li></ul><p>代码：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//悲观锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public synchronized void add(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ReentrantLock -- 悲观锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void modifyPublicResources() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 操作同步资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //一定要放在finally让锁一定会释放</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//乐观锁--- 需要保证多个线程使用的是同一个AtomicInteger</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private AtomicInteger atomicInteger = new AtomicInteger();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">atomicInteger.incrementAndGet(); //执行自增1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong><code>AtomicInteger</code></strong> 是 <strong><code>java.util.concurrent</code></strong> 包中的原子类，就是通过CAS来实现乐观锁。CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。<strong><code>java.util.concurrent</code></strong> 包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类 <strong><code>AtomicInteger</code></strong> 的源码，看一下  <strong><code>AtomicInteger</code></strong> 的定义(JDK11的代码)：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * This class intended to be implemented using VarHandles, but there</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * are unresolved cyclic startup dependencies.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, &quot;value&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile int value;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>看一下getAndIncrement的实现</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    //获取并且增加</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public final int getAndIncrement() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return U.getAndAddInt(this, VALUE, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @HotSpotIntrinsicCandidate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public final int getAndAddInt(Object o, long offset, int delta) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            v = getIntVolatile(o, offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } while (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @HotSpotIntrinsicCandidate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public final boolean weakCompareAndSetInt(Object o, long offset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                              int expected,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                              int x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return compareAndSetInt(o, offset, expected, x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @HotSpotIntrinsicCandidate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public final native boolean compareAndSetInt(Object o, long offset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                 int expected,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                 int x);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>CAS算法的三个问题：</p><ul><li><strong>ABA问题</strong> 。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</li><li><strong>循环时间长开销大</strong> 。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li><li><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-自旋锁-vs-适应性自旋锁">3. 自旋锁 VS 适应性自旋锁<a class="hash-link" href="#3-自旋锁-vs-适应性自旋锁" title="Direct link to heading">​</a></h3><p>自旋锁概念：阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><p>自旋锁体现在代码上面就是通过循环来实现，例如 <strong><code>AtomicInteger</code></strong> 的 <strong><code>getAndIncrement</code></strong> 方法就是通过循环不断的来尝试。</p><p><img loading="lazy" src="https://raw.githubusercontent.com/mxsm/document/master/image/JSE/%E8%87%AA%E6%97%8B%E9%94%81%E5%9B%BE%E8%A7%A3.png" alt="图解" class="img_ev3q"></p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用         <strong><code>-XX:PreBlockSpin</code></strong> 来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> @HotSpotIntrinsicCandidate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public final int getAndAddInt(Object o, long offset, int delta) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //通过循环来自旋直到修改成功</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            v = getIntVolatile(o, offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } while (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁">4. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁<a class="hash-link" href="#4-无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁" title="Direct link to heading">​</a></h3><p>首先为什么Synchronized能实现线程同步？</p><p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="java对象头">Java对象头<a class="hash-link" href="#java对象头" title="Direct link to heading">​</a></h4><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p><p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark  Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark  Word里存储的数据会随着锁标志位的变化而变化。</p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="monitor">Monitor<a class="hash-link" href="#monitor" title="Direct link to heading">​</a></h4><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor   record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK  6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK  6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p><p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p><table><thead><tr><th align="center">锁状态</th><th align="left">存储类容</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">无锁</td><td align="left">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td align="center">01</td></tr><tr><td align="center">偏向锁</td><td align="left">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td align="center">01</td></tr><tr><td align="center">轻量级锁</td><td align="left">指向栈中锁记录的指针</td><td align="center">00</td></tr><tr><td align="center">重量级锁</td><td align="left">指向互斥量（重量级锁）的指针</td><td align="center">10</td></tr></tbody></table><p><strong>无锁</strong></p><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><p><strong>偏向锁</strong></p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在Mark  Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark  Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><p><strong>轻量级锁</strong></p><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock  Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><p><strong>重量级锁</strong></p><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><p>整体的锁状态升级流程如下：</p><p><img loading="lazy" src="https://raw.githubusercontent.com/mxsm/document/master/image/JSE/%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B.png" alt="图片" class="img_ev3q"></p><p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5-公平锁-vs-非公平锁">5 公平锁 VS 非公平锁<a class="hash-link" href="#5-公平锁-vs-非公平锁" title="Direct link to heading">​</a></h3><p>公平和不公平是看是否按照先来后到的顺序。</p><ul><li><strong>公平锁</strong>：指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。<ul><li><strong>优点</strong>：等待锁的线程不会饿死</li><li><strong>缺点</strong>：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</li></ul></li><li><strong>非公平锁</strong>：多个线程加锁时<strong>直接尝试获取锁</strong> ，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁 <strong>有可能出现后申请锁的线程先获取锁的场景</strong> 。<ul><li><strong>优点</strong>：可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。</li><li><strong>缺点</strong>：处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</li></ul></li></ul><hr><p>公平锁图解：</p><p><img loading="lazy" src="https://raw.githubusercontent.com/mxsm/document/master/image/JSE/%E5%85%AC%E5%B9%B3%E9%94%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E8%A7%A3.png" alt="图解" class="img_ev3q"></p><hr><p>非公平锁图解：</p><p><img loading="lazy" src="https://raw.githubusercontent.com/mxsm/document/master/image/JSE/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%9B%BE%E8%A7%A3.png" alt="图解" class="img_ev3q"></p><p>公平锁和非公平锁在Java中的实现，以 <strong><code>ReentrantLock</code></strong> (重入锁)为例子：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package java.util.concurrent.locks;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.concurrent.TimeUnit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Collection;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ReentrantLock implements Lock, java.io.Serializable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final long serialVersionUID = 7373984872572414699L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** Synchronizer providing all implementation mechanics */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Sync sync;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Base of synchronization control for this lock. Subclassed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * into fair and nonfair versions below. Uses AQS state to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * represent the number of holds on the lock.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    abstract static class Sync extends AbstractQueuedSynchronizer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static final long serialVersionUID = -5179523762034025860L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Performs {@link Lock#lock}. The main reason for subclassing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * is to allow fast path for nonfair version.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        abstract void lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Performs non-fair tryLock.  tryAcquire is implemented in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * subclasses, but both need nonfair try for trylock method.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final boolean nonfairTryAcquire(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Thread current = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = getState();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (c == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (compareAndSetState(0, acquires)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    setExclusiveOwnerThread(current);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (current == getExclusiveOwnerThread()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int nextc = c + acquires;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (nextc &lt; 0) // overflow</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setState(nextc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected final boolean tryRelease(int releases) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = getState() - releases;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (Thread.currentThread() != getExclusiveOwnerThread())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new IllegalMonitorStateException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean free = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (c == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                free = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setExclusiveOwnerThread(null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setState(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return free;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected final boolean isHeldExclusively() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // While we must in general read state before owner,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // we don&#x27;t need to do so to check if current thread is owner</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return getExclusiveOwnerThread() == Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final ConditionObject newCondition() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new ConditionObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Methods relayed from outer class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Thread getOwner() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return getState() == 0 ? null : getExclusiveOwnerThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final int getHoldCount() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return isHeldExclusively() ? getState() : 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final boolean isLocked() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return getState() != 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Reconstitutes the instance from a stream (that is, deserializes it).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private void readObject(java.io.ObjectInputStream s)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throws java.io.IOException, ClassNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            s.defaultReadObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setState(0); // reset to unlocked state</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Sync object for non-fair locks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final class NonfairSync extends Sync {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static final long serialVersionUID = 7316153563782823691L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Performs lock.  Try immediate barge, backing up to normal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * acquire on failure.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final void lock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (compareAndSetState(0, 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setExclusiveOwnerThread(Thread.currentThread());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                acquire(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected final boolean tryAcquire(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return nonfairTryAcquire(acquires);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Sync object for fair locks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final class FairSync extends Sync {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static final long serialVersionUID = -3000897897090466540L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final void lock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            acquire(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 公平锁tryAcquire的实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected final boolean tryAcquire(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Thread current = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = getState(); //获取资源的状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (c == 0) {// 为0表明资源没有被占用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //公平锁多了一个hasQueuedPredecessors判断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!hasQueuedPredecessors() &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    compareAndSetState(0, acquires)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    setExclusiveOwnerThread(current);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (current == getExclusiveOwnerThread()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int nextc = c + acquires;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (nextc &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setState(nextc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //默认创建的是非公平锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ReentrantLock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sync = new NonfairSync();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //true公平锁，false非公平锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ReentrantLock(boolean fair) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sync = fair ? new FairSync() : new NonfairSync();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void lock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sync.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void lockInterruptibly() throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sync.acquireInterruptibly(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //尝试获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean tryLock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return sync.nonfairTryAcquire(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //尝试获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean tryLock(long timeout, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void unlock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sync.release(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //判断是否为公平锁--公平锁和非公平锁两种实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public final boolean isFair() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return sync instanceof FairSync;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//判断当前线程是否为队列的的第一个    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final boolean hasQueuedPredecessors() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // The correctness of this depends on head being initialized</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // before tail and on head.next being accurate if the current</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // thread is first in queue.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node t = tail; // Read fields in reverse initialization order</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node h = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return h != t &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((s = h.next) == null || s.thread != Thread.currentThread());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从上面的实现来看，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。符合公平锁和非公平锁的特点。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6-可重入锁-vs-非可重入锁">6. 可重入锁 VS 非可重入锁<a class="hash-link" href="#6-可重入锁-vs-非可重入锁" title="Direct link to heading">​</a></h3><ul><li><p><strong>可重入锁</strong>：又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入该线程内层方法会自动获取锁（前提锁对象得是同一个对象或者class）。不会因为之前或去过还没释放而阻塞。Java中 <strong><code>ReentrantLock</code></strong> 和 <strong><code>synchronized</code></strong> 都是可重入锁。</p><ul><li>优点：一定程度避免死锁。</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class A {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void a() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;a...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        b();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void b() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;b...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>两个方法都是被内置锁synchronized修饰，a方法中调用了b方法。因为内置锁可以重入。所以线程在调用b方法的时候可以直接获取对象的锁，进入b方法进行操作，如果非重入锁，由于a和b锁是同一个对象。那么当前线程调用b之前要将执行a时获取当前的对象的锁释放掉，然而在没有运行完a方法，当前线程释放不了当前对象锁。所以出现死锁的现象。通俗的说：<strong>把a和b方法当做两个房间，重入锁好比，进入a放假的钥匙同样能够进入b房间然后完成一一锁好退出来。非重入锁：先进入了a房间，但是要走出a房间释放a房间需要进入b房间。但是b房间的钥匙被a房间用了不能重复使用。这样导致了死锁，导致出不去a房间也进不去b房间</strong>。</p></li><li><p><strong>非可重入锁</strong>：锁对象被占用后在没有释放之前不允许其他的线程获取同一个锁。Java中的 <strong><code>NonReentrantLock</code></strong> 就是非可重入锁的实现</p></li></ul><p>重入锁图解：</p><p><img loading="lazy" src="https://github.com/mxsm/document/blob/master/image/JSE/%E9%87%8D%E5%85%A5%E9%94%81%E5%9B%BE%E8%A7%A3.png?raw=true" alt="重入锁图解" class="img_ev3q"></p><p>非重入锁图解：</p><p><img loading="lazy" src="https://github.com/mxsm/document/blob/master/image/JSE/%E9%9D%9E%E9%87%8D%E5%85%A5%E9%94%81%E5%9B%BE%E8%A7%A3.png?raw=true" alt="图解" class="img_ev3q"></p><p>以 <strong><code>NonReentrantLock</code></strong> 和 <strong><code>ReentrantLock</code></strong> 的代码来看一下实现的区别(JDK8)</p><p>首先是非重入锁（ <strong><code>NonReentrantLock</code></strong> ）：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    //锁的获取   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected boolean tryAcquire(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //直接通过compareAndSetState来获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (compareAndSetState(0, 1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //设置当前锁的拥有者为当前的获取锁线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            owner = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;//获取成功返回true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;//获取失败返回false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//锁的释放</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected boolean tryRelease(int releases) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //判断释放锁的线程是否为拥有锁的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Thread.currentThread() != owner) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalMonitorStateException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        owner = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //直接修改为0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setState(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对比看一下重入锁（ <strong><code>ReentrantLock</code></strong> ）：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//尝试获取锁--非公平锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final boolean nonfairTryAcquire(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Thread current = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = getState();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //没有线程占有锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (c == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (compareAndSetState(0, acquires)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    setExclusiveOwnerThread(current);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //判断获取锁的线程和之前获取锁的线程是否为同一个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (current == getExclusiveOwnerThread()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //如果是state+acquires(该数值为1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int nextc = c + acquires;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (nextc &lt; 0) // overflow</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setState(nextc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       //重入锁的释放</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected final boolean tryRelease(int releases) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //释放的占有锁的线程数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = getState() - releases;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //对线程进行判断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (Thread.currentThread() != getExclusiveOwnerThread())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new IllegalMonitorStateException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //默认是释放失败的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean free = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //如果为0释放完</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (c == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                free = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //独有的锁的拥有线程设置为null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setExclusiveOwnerThread(null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //设置status的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setState(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return free;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从上面的代码分析通过对status值的控制来实现重入锁和非重入锁。而 <strong><code>synchronized</code></strong> 是虚拟机底层实现。水平有限没办法分析。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="7-独享锁-vs-共享锁">7 独享锁 VS 共享锁<a class="hash-link" href="#7-独享锁-vs-共享锁" title="Direct link to heading">​</a></h3><ul><li><strong>独享锁</strong>：也叫做排他锁，是指该锁只能被一个线程所持有。线程T对数据A加上排他锁后，其他线程不能对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的 <strong>synchronized</strong> 和JUC( <strong><code>java.util.concurrent</code></strong> )中Lock的实现类就是互斥锁—(<a href="http://www.iocoder.cn/JUC/good-collection/" target="_blank" rel="noopener noreferrer">锁的相关文章</a>)。 <strong><code>ReentrantReadWriteLock.WriteLock</code></strong></li><li><strong>共享锁</strong>：该锁可以被多个线程持有，如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得<strong>共享锁的线程只能读数据，不能修改数据</strong>。 <strong><code>ReentrantReadWriteLock.ReadLock</code></strong></li></ul><p>独享锁和共享锁都是通过AbstractQueuedSynchronizer(简称AQS)，队列同步器来实现的。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class ReentrantReadWriteLock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        implements ReadWriteLock, java.io.Serializable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final long serialVersionUID = -6992448646407690164L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** 内部类提供的读锁 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ReentrantReadWriteLock.ReadLock readerLock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** 内部类提供的写锁 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ReentrantReadWriteLock.WriteLock writerLock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** Performs all synchronization mechanics */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Sync sync;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 读写说默认创建的是非公平锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ReentrantReadWriteLock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ReentrantReadWriteLock(boolean fair) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sync = fair ? new FairSync() : new NonfairSync();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        readerLock = new ReadLock(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        writerLock = new WriteLock(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Sync代码</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">        static final int SHARED_SHIFT   = 16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //读锁和写锁的最大值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //独占锁写的标志位int的第16位</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** Returns the number of shared holds represented in count  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        static int sharedCount(int c)    { return c &gt;&gt;&gt; SHARED_SHIFT; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /***/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong><code>ReentrantReadWriteLock.WriteLock（重入锁）</code></strong> 的加锁代码</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//加锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void lock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sync.acquire(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//方法acquire</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final void acquire(int arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!tryAcquire(arg) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            selfInterrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected final boolean tryAcquire(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //获取当前的获取锁的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread current = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //获取当前锁的个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = getState();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //获取写锁的数量--低16位</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int w = exclusiveCount(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //不等于0--已经有线程持有了锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (c != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 //写锁为0总的锁不为0说明存在读锁，或者当前线程不是持有锁的线程返回false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (w == 0 || current != getExclusiveOwnerThread())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //现有的写锁加上当前的锁大于最大值MAX_COUNT 抛错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (w + exclusiveCount(acquires) &gt; MAX_COUNT 抛错)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Reentrant acquire</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //设置锁的数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setState(c + acquires);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //对于非公平锁writerShouldBlock在JDK8中总是返回false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (writerShouldBlock() ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                !compareAndSetState(c, c + acquires))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setExclusiveOwnerThread(current);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从上面的代码梳理一下 <strong><code>WriteLock</code></strong> 加锁的过程：</p><ol><li>调用 <strong><code>ReentrantReadWriteLock.WriteLock</code></strong> 对象的 <strong><code>lock</code></strong> 方法。</li><li><strong><code>lock</code></strong> 方法调用 <strong><code>sync.acquire(1)</code></strong> ，获取的值为1。</li><li><strong><code>tryAcquire</code></strong>尝试获取锁，如果获取成功就不用执行下一个判断 <strong><code>acquireQueued</code></strong></li></ol><p><strong><code>tryAcquire</code></strong> 的获取加锁过程：</p><ol><li>获取当前线程 <strong><code>current</code></strong> (这个只的是获取锁对象的线程)</li><li>获取锁的个数 <strong><code>c</code></strong>(读锁和写锁)</li><li>获取写锁的个数 <strong><code>w</code></strong>（int的低16位）</li><li>判断锁的数量 <strong><code>c</code></strong>不等于0<ul><li>不等于0<ul><li>写锁<strong><code>w</code></strong>等于0或者获取锁的线程不等于锁的拥有者线程，返回<strong><code>false</code></strong></li><li>写锁<strong><code>w</code></strong>+请求的锁 &gt; 写锁的最大值MAX_COUNT，直接抛错</li><li>设置设置锁的数量然后返回true获取锁成功</li></ul></li></ul></li><li>对于非公平锁 <strong><code>writerShouldBlock()</code></strong> 一直返回的是false,所以看后面的 <strong><code>compareAndSetState</code></strong> 的设置如果失败返回 <strong><code>false</code></strong> 获取写锁失败</li><li><strong><code>compareAndSetState</code></strong> 设置成功，设置当前说的拥有者为现在获取线程的对象。</li></ol><hr><p><strong><code>ReentrantReadWriteLock.ReadLock</code></strong> 的加锁代码</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">        @ReservedStackAccess</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected final int tryAcquireShared(int unused) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * Walkthrough:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * 1. 如果另一个线程持有写锁,获取读锁失败.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * 2. Otherwise, this thread is eligible for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             *    lock write state, so ask if it should block</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             *    because of queue policy. If not, try</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             *    to grant by CASing state and updating count.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             *    Note that step does not check for reentrant</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             *    acquires, which is postponed to full version</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             *    to avoid having to check hold count in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             *    the more typical non-reentrant case.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * 3. If step 2 fails either because thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             *    apparently not eligible or CAS fails or count</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             *    saturated, chain to version with full retry loop.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread current = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = getState();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (exclusiveCount(c) != 0 &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                getExclusiveOwnerThread() != current)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int r = sharedCount(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!readerShouldBlock() &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                r &lt; MAX_COUNT &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                compareAndSetState(c, c + SHARED_UNIT)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (r == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    firstReader = current;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    firstReaderHoldCount = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (firstReader == current) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    firstReaderHoldCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    HoldCounter rh = cachedHoldCounter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (rh == null ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        rh.tid != LockSupport.getThreadId(current))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cachedHoldCounter = rh = readHolds.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else if (rh.count == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        readHolds.set(rh);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    rh.count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return fullTryAcquireShared(current);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>可以看到在tryAcquireShared(int
unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="8-锁的总结">8. 锁的总结<a class="hash-link" href="#8-锁的总结" title="Direct link to heading">​</a></h3><table><thead><tr><th>锁</th><th>公平锁</th><th>非公平锁</th><th>重入锁</th><th>非重入锁</th><th>独享锁</th><th>共享锁</th><th>悲观锁</th><th>乐观锁</th><th>自旋锁</th><th>适应性自旋锁</th></tr></thead><tbody><tr><td>synchronized</td><td>×</td><td>√</td><td>√</td><td>×</td><td>√</td><td>×</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>ReentrantLock</td><td>看构造函数</td><td>看构造函数</td><td>√</td><td>×</td><td>√</td><td>×</td><td>√</td><td>×</td><td>√</td><td>√</td></tr><tr><td>NonReentrantLock</td><td>看构造函数</td><td>看构造函数</td><td>×</td><td>√</td><td>√</td><td>×</td><td>√</td><td>×</td><td>√</td><td>√</td></tr><tr><td>ReadLock</td><td>看构造函数</td><td>看构造函数</td><td>√</td><td>×</td><td>×</td><td>√</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>WriteLock</td><td>看构造函数</td><td>看构造函数</td><td>√</td><td>×</td><td>√</td><td>×</td><td>√</td><td>×</td><td>√</td><td>√</td></tr></tbody></table><p>参考文档：<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener noreferrer">不可不说的Java“锁”事--来自美团</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/mxsm/mxsm-website/edit/develop/docs/java/java-se/lock/java-lock.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2023-01-20T15:10:39.000Z">Jan 20, 2023</time></b> by <b>mxsm</b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/java/java-se/lock/distributed-lock"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">分布式锁</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/java/java-se/lock/synchronized"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java中的琐事-synchronized</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-锁的特性" class="table-of-contents__link toc-highlight">1. 锁的特性</a></li><li><a href="#2-悲观锁--vs-乐观锁" class="table-of-contents__link toc-highlight">2. 悲观锁  VS 乐观锁</a></li><li><a href="#3-自旋锁-vs-适应性自旋锁" class="table-of-contents__link toc-highlight">3. 自旋锁 VS 适应性自旋锁</a></li><li><a href="#4-无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁" class="table-of-contents__link toc-highlight">4. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</a><ul><li><a href="#java对象头" class="table-of-contents__link toc-highlight">Java对象头</a></li><li><a href="#monitor" class="table-of-contents__link toc-highlight">Monitor</a></li></ul></li><li><a href="#5-公平锁-vs-非公平锁" class="table-of-contents__link toc-highlight">5 公平锁 VS 非公平锁</a></li><li><a href="#6-可重入锁-vs-非可重入锁" class="table-of-contents__link toc-highlight">6. 可重入锁 VS 非可重入锁</a></li><li><a href="#7-独享锁-vs-共享锁" class="table-of-contents__link toc-highlight">7 独享锁 VS 共享锁</a></li><li><a href="#8-锁的总结" class="table-of-contents__link toc-highlight">8. 锁的总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/mxsm" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 mxsm(蚂蚁背大象), Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.03db58b2.js"></script>
<script src="/assets/js/main.7a1c57b2.js"></script>
</body>
</html>