<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-java/java-se/concurrencemultithreading/threadpool">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">线程池源码解析 | mxsm(蚂蚁背大象)</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://blog.ljbmxsm.com/docs/java/java-se/concurrencemultithreading/threadpool"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="线程池源码解析 | mxsm(蚂蚁背大象)"><meta data-rh="true" name="description" content="1. 线程池的继承关系"><meta data-rh="true" property="og:description" content="1. 线程池的继承关系"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://blog.ljbmxsm.com/docs/java/java-se/concurrencemultithreading/threadpool"><link data-rh="true" rel="alternate" href="https://blog.ljbmxsm.com/docs/java/java-se/concurrencemultithreading/threadpool" hreflang="en"><link data-rh="true" rel="alternate" href="https://blog.ljbmxsm.com/docs/java/java-se/concurrencemultithreading/threadpool" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="mxsm(蚂蚁背大象) RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="mxsm(蚂蚁背大象) Atom Feed">




<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-141789564-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-226F0LR9KE"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-226F0LR9KE",{anonymize_ip:!0})</script><link rel="stylesheet" href="/assets/css/styles.efb36c14.css">
<link rel="preload" href="/assets/js/runtime~main.4a7cd42b.js" as="script">
<link rel="preload" href="/assets/js/main.5f86cb15.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><div class="announcementBar_mb4j" role="banner"><div class="announcementBarPlaceholder_vyr4"></div><div class="content_knG7 announcementBarContent_xLdY">⭐️ If you like, give it a star on <a target="_blank" rel="noopener noreferrer" href="https://github.com/mxsm/mxsm-website">GitHub</a> and follow me. This web site is updating!! </div><button type="button" aria-label="Close" class="clean-btn close closeButton_CVFx announcementBarClose_gvF7"><svg viewBox="0 0 15 15" width="14" height="14"><g stroke="currentColor" stroke-width="3.1"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate"></b></a><a class="navbar__item navbar__link" href="/docs/intro">Tutorial</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">RocketMQ</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/rocketmq/rocketmq5">RocketMQ 5.0</a></li><li><a class="dropdown__link" href="/docs/rocketmq/rocketmq4">RocketMQ 4.X</a></li><li><a href="https://github.com/apache/rocketmq" target="_blank" class="dropdown__link">RocketMQ GitHub<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://rocketmq.apache.org/" target="_blank" class="dropdown__link">RocketMQ official website<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><a class="navbar__item navbar__link" href="/docs/event-mesh/">EventMesh</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Spring</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/spring/spring-framework">Spring Framework</a></li><li><a class="dropdown__link" href="/docs/spring/spring-boot">Spring Boot</a></li><li><a class="dropdown__link" href="/docs/spring/spring-cloud">Spring Cloud</a></li><li><a href="https://spring.io/" target="_blank" class="dropdown__link">Spring official website<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Java</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/java/java-se">Java SE</a></li><li><a class="dropdown__link" href="/docs/java/java-web">Java Web</a></li><li><a class="dropdown__link" href="/docs/java/java-tools">Java Tools</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Rust</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/rust/official-doc">Rust官方文档(翻译)</a></li><li><a class="dropdown__link" href="/docs/rust/rust-learn/introduction">Rust学习</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">C++</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/java/java-se">Java SE</a></li><li><a class="dropdown__link" href="/docs/java/java-web">Java Web</a></li><li><a class="dropdown__link" href="/docs/java/java-tools">Java Tools</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Cloud Native</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/cloud-native/open-telemetry">OpenTelemetry</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Middleware</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/netty/">Netty</a></li><li><a class="dropdown__link" href="/docs/redis">Redis</a></li><li><a class="dropdown__link" href="/docs/intro">Kafka-改造中</a></li><li><a class="dropdown__link" href="/docs/intro">Etcd-改造中</a></li><li><a class="dropdown__link" href="/docs/docker">Docker</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Database</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/intro">SQL-改造中</a></li><li><a class="dropdown__link" href="/docs/intro">MySQL-改造中</a></li><li><a class="dropdown__link" href="/docs/intro">PostgreSQL-改造中</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Theory</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/intro">SQL</a></li><li><a class="dropdown__link" href="/docs/intro">MySQL</a></li><li><a class="dropdown__link" href="/docs/intro">PostgreSQL</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Others</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/others/blog-building">Blog building</a></li><li><a class="dropdown__link" href="/docs/others/tools">Develop Tools</a></li><li><a class="dropdown__link" href="/docs/intro">PostgreSQL</a></li></ul></div><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/mxsm" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG menuWithAnnouncementBar_GW3s"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/java/java-se">Overview</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/java/java-se/JVM/jvm-optimize">JVM</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/jvm-optimize">JVM调优实战：优化Java应用程序的性能</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/jvm-adjust">Java常用JVM参数实战</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/Java-object-header">深入理解Java对象头Mark Word</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/class-loader">类的加载</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/java-gc-log">Java GC日志图解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/java-must-know-command">Linux下Java开发者必须知道的那些Java命令</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/java-object-size">一个Java对象占用多大内存</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/java-ref">Java中的引用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/jvm-common-command">JVM常用的命令</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/jvm-gc">JVM垃圾收集器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/jvm-memory-model">JVM的内存模型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/jvm-paramters">JVM参数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/JVM/parental-delegate-model">类加载器和双亲委派模型</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/java/java-se/lock/distributed-lock">Lock</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/lock/distributed-lock">分布式锁</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/lock/java-lock">Java中的那些锁事-1</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/lock/synchronized">Java中的琐事-synchronized</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/java/java-se/concurrencemultithreading/AQS">Thread</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/AQS">AQS源码解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/AtomicXxxFieldUpdater">AtomicXXXFieldUpdater在内存优化中的是实战</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/CompletableFuture">CompletableFuture详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/JUC-atomic-class">JUC包中的原子类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/LockSupport">LockSupport用法和原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/ThreadLocal-source-analysis">ThreadLocal源码解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/callable-and-runnable">Callable与Runnable的区别你知道吗？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/java-concurrency-three-concept">Java并发编程中的三个概念</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/not-suggest-use-exectors">为什么不建议使用Executors创建线程池？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/queue">Java队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/thread-common-method">Thread的常用方法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool-handler-exception">线程池异常你都了解如何处理吗？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool-how-to-chosice">threadpool-how-to-chosice</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool-must-shutdown">揭秘为什么主线程结束了Java线程池还在运行</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool-thread-notice">线程池的线程的类型你是否了解？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool-thread-number-practice">线程池的数量和线程池中线程数量如何设置-实践篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool-thread-number">线程池的数量和线程池中线程数量如何设置-理论篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadpool">线程池源码解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/concurrencemultithreading/threadstate">线程的状态</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/java/java-se/javaio/BIO-NIO-AIO">IO</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/javaio/BIO-NIO-AIO">BIO NIO AIO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/javaio/io-explain">IO详解--分类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/javaio/java-nio-base">Java NIO 知识梳理和例子</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/javaio/nio-bytebuffer">Java NIO ByteBuffer使用图文详解</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/java/java-se/jdksourcereading/collection/ArrayList">Source Code Analysis</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/java/java-se/jdksourcereading/collection/ArrayList">collection</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/java/java-se/jdksourcereading/map/EnumMap">map</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/java/java-se/others/String StringBuffer StringBuilder">Others</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/String StringBuffer StringBuilder">String StringBuffer StringBuilder</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/async-profiler">Java 性能分析工具 async-profiler</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/bean-validation">如何自定义Bean validation实现数据校验</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/common-jdk-command">JVM常用的命令-JDK8</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/dynamic-static">动态代理与静态代理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/interface-abstract-class">接口抽象类的抉择</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/java-application-get-pid">Java程序中获取当前进程的进程ID(Pid)</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/java-modifier">Java修饰符</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/java-operator">Java操作符</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/java-sharp-design">Java源码简单吊炸天的设计</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/java-threadpool-experience">SpringBoot项目中线程池在服务类方法中创建后导致线程数量暴增</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/mapstruct">Spring BeanUtils从精通到放弃，Mapstruct从入门到精通</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/operators">业务开发中巧妙运用位运算</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/show-thread-use-cpu">查看线程的CPU使用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/string-concat">字符串拼接那些事</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/threadpool-used-error">Java线程池使用不当会发生什么-生产案例</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-se/others/volatile">volatile详解</a></li></ul></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Thread</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">线程池源码解析</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>线程池源码解析</h1></header><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-线程池的继承关系">1. 线程池的继承关系<a href="#1-线程池的继承关系" class="hash-link" aria-label="Direct link to 1. 线程池的继承关系" title="Direct link to 1. 线程池的继承关系">​</a></h3><p><img loading="lazy" src="https://github.com/mxsm/document/blob/master/image/JSE/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png?raw=true" alt="图片" class="img_ev3q"></p><p>从上图可以看出来最顶层的接口为 <strong><code>Executor</code></strong> ,下面看一下这个接口中的方法</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public interface Executor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //只有一个方法execute</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void execute(Runnable command);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p> 从代码中可以看出来只有一个 <strong><code>execute</code></strong> 方法。这也是我常用的一个来运行 <strong><code>Runable</code></strong> 的一种方式。然后看一下继承了 <strong><code>Executor</code></strong> 接口的 <strong><code>ExecutorService</code></strong> 接口中有哪些我们熟悉的而常用的方法</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public interface ExecutorService extends Executor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 关闭线程池，已提交的任务继续执行，不接受继续提交新任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //写例子的时候用到(PS在实际的项目组基本上没有用到，反正我是没有)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void shutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //关闭线程池，尝试停止正在执行的所有任务，不接受继续提交新任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     //这个也是基本上没用到</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;Runnable&gt; shutdownNow();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 线程池是否已关闭</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 还是没有用到</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean isShutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个方法必须在调用shutdown或shutdownNow方法之后调用才会返回true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //尴尬没用过</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean isTerminated();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //一脸懵逼没用过</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean awaitTermination(long timeout, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   //带返回值的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //带返回值的 -- 这个很少用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //带返回值---(成功返回值为null 有兴趣的可以去尝试一下，源码的英文注释上面有说明)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Future&lt;?&gt; submit(Runnable task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //批量全部执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //批量全部执行--在规定的时间内</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  long timeout, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   //任意一个先执行完就返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException, ExecutionException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //任意一个先执行完就返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    long timeout, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException, ExecutionException, TimeoutException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>演示代码：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class InvokeAllTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws  Exception{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorService service = Executors.newFixedThreadPool(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Collection&lt;Test&gt; a = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; 10; ++i){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            a.add(new Test());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //System.out.println( service.invokeAny(a));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println( service.invokeAll(a));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Test implements Callable&lt;String&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Computes a result, or throws an exception if unable to do so.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return computed result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @throws Exception if unable to compute a result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String call() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TimeUnit.SECONDS.sleep((int)(Math.random()*10));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Thread.currentThread().getName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>看一下最后一个接口 <strong><code>ScheduledExecutorService</code></strong> 计划执行接口，从命名上就不难看出来这个用于执行任务的。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public interface ScheduledExecutorService extends ExecutorService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建并执行在给定延迟之后启用的一次性操作。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       long delay, TimeUnit unit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建并执行在给定延迟之后启用的一次性操作。返回ScheduledFuture&lt;V&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                           long delay, TimeUnit unit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 按指定频率周期执行某个任务。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                  long initialDelay,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                  long period,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                  TimeUnit unit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 按指定频率间隔执行某个任务。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                     long initialDelay,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                     long delay,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                     TimeUnit unit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>另外，由于线程池支持<strong>获取线程执行的结果</strong>，所以，引入了 Future 接口，RunnableFuture 继承自此接口，然后我们最需要关心的就是它的实现类 FutureTask。到这里，记住这个概念，在线程池的使用过程中，我们是往线程池提交任务（task），使用过线程池的都知道，我们提交的每个任务是实现了 Runnable 接口的，其实就是先将 Runnable 的任务包装成 FutureTask，然后再提交到线程池。这样，读者才能比较容易记住 FutureTask 这个类名：它首先是一个任务（Task），然后具有 Future 接口的语义，即可以在将来（Future）得到执行的结果。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2--abstractexecutorservice">2.  <strong><code>AbstractExecutorService</code></strong><a href="#2--abstractexecutorservice" class="hash-link" aria-label="Direct link to 2--abstractexecutorservice" title="Direct link to 2--abstractexecutorservice">​</a></h3><p>接着来看一下在抽象类 <strong><code>AbstractExecutorService</code></strong> 实现了哪些方法</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractExecutorService implements ExecutorService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Runnable 转换为 Callable 的方法带指定返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new FutureTask&lt;T&gt;(runnable, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Runnable 转换为 Callable 的方法，不带指定返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new FutureTask&lt;T&gt;(callable);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Future&lt;?&gt; submit(Runnable task) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (task == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //这里看一看出来在Runnable submit方法返回值为Future get的值为null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        execute(ftask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ftask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (task == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         //这里看一看出来在Runnable submit方法返回值为Future get的值为result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        execute(ftask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ftask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Callable类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (task == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        execute(ftask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ftask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 返回任意一个执行完成的结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              boolean timed, long nanos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException, ExecutionException, TimeoutException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tasks == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int ntasks = tasks.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ntasks == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //Future列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorCompletionService&lt;T&gt; ecs =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new ExecutorCompletionService&lt;T&gt;(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ExecutionException ee = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //截止时间---0就是没有截止时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final long deadline = timed ? System.nanoTime() + nanos : 0L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            futures.add(ecs.submit(it.next()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            --ntasks;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int active = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //返回已经完成的任务Future&lt;T&gt; 没有就返回null -- 不停的循环轮询</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Future&lt;T&gt; f = ecs.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (f == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (ntasks &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        --ntasks;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        futures.add(ecs.submit(it.next()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ++active;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else if (active == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else if (timed) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (f == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            throw new TimeoutException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        nanos = deadline - System.nanoTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        f = ecs.take();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (f != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    --active;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return f.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (ExecutionException eex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ee = eex;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (RuntimeException rex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ee = new ExecutionException(rex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ee == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ee = new ExecutionException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw ee;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0, size = futures.size(); i &lt; size; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                futures.get(i).cancel(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException, ExecutionException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return doInvokeAny(tasks, false, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (TimeoutException cannotHappen) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            assert false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                           long timeout, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException, ExecutionException, TimeoutException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return doInvokeAny(tasks, true, unit.toNanos(timeout));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tasks == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //创建返回值Future 的列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean done = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //放入线程池运行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Callable&lt;T&gt; t : tasks) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                futures.add(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                execute(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //等待运行完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0, size = futures.size(); i &lt; size; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Future&lt;T&gt; f = futures.get(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!f.isDone()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        f.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (CancellationException ignore) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (ExecutionException ignore) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            done = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return futures;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!done)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //将没有运行完成的线程直接取消掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (int i = 0, size = futures.size(); i &lt; size; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    futures.get(i).cancel(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         long timeout, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tasks == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long nanos = unit.toNanos(timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean done = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //创建任务数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Callable&lt;T&gt; t : tasks)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                futures.add(newTaskFor(t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //截止时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final long deadline = System.nanoTime() + nanos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final int size = futures.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //减去提交的时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; size; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                execute((Runnable)futures.get(i));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nanos = deadline - System.nanoTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //小于0直接返回现有的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (nanos &lt;= 0L)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return futures;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //处理每个获取的时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; size; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Future&lt;T&gt; f = futures.get(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!f.isDone()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (nanos &lt;= 0L)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return futures;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        f.get(nanos, TimeUnit.NANOSECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (CancellationException ignore) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (ExecutionException ignore) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (TimeoutException toe) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        //发现timeout直接返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return futures;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    nanos = deadline - System.nanoTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            done = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return futures;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!done)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //返回后发现还有在运行的直接cacel掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (int i = 0, size = futures.size(); i &lt; size; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    futures.get(i).cancel(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从上面可以看出来上面方法实现主要是通过调用  <strong><code>execute</code></strong> 和 <strong><code>ExecutorCompletionService</code></strong> 这个类。来实现了 <strong><code>submit</code></strong> , <strong><code>doInvokeAny</code></strong>  ,<strong><code>invokeAll</code></strong> 这些方法。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-看看最常用的实现-threadpoolexecutor">3. 看看最常用的实现 <strong><code>ThreadPoolExecutor</code></strong><a href="#3-看看最常用的实现-threadpoolexecutor" class="hash-link" aria-label="Direct link to 3-看看最常用的实现-threadpoolexecutor" title="Direct link to 3-看看最常用的实现-threadpoolexecutor">​</a></h3><p>首先我们来看一下 <strong><code>ThreadPoolExecutor</code></strong> 类中包含的成员变量进行逐一的分析</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//从开始的继承图可以看出来 ThreadPoolExecutor继承了AbstractExecutorService</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ThreadPoolExecutor extends AbstractExecutorService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 主线程池控制状态ctl是一个atomic整型封装了两个概念字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *   线程数量, 定义了有效的线程数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *   运行状态,    定义了：运行状态，关闭状态等等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 为了封装成一个整数, 我们限制线程的数量为</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * (2^29)-1 (about 500 million) 而不是 (2^31)-1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 如果将来出现这种情况，可以将变量更改为AtomicLong，并调整下面的shift/mask常量。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 但是在需要之前，这段代码使用int会更快、更简单。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 工作线程是允许启动和停止的，工作线程可能会有和存活的线程有短暂的数量不同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *   RUNNING:  接受新任务并处理排队的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *   SHUTDOWN: 不接受新任务但是处理排队任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *   STOP:     不接受新任务不接受排队任务，并且中断在处理中的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *   TIDYING(整理):  所有的任务中止, 工作线程为0，转换到状态清理的线程将运行terminate()钩子方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *   TERMINATED: terminated() 已经完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The numerical order among these values matters, to allow</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * ordered comparisons. The runState monotonically increases over</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * time, but need not hit each state. The transitions are:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * RUNNING -&gt; SHUTDOWN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *     调用shutdown(),或者在finalize()中调用shutdown()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * (RUNNING or SHUTDOWN) -&gt; STOP</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *    调用shutdownNow()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * SHUTDOWN -&gt; TIDYING</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *    当队列和线程池都为空的时候</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * STOP -&gt; TIDYING</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *    当线程池为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * TIDYING -&gt; TERMINATED</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *    terminated() 方法执行完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //线程的数量的表示位--低29位表示线程数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int COUNT_BITS = Integer.SIZE - 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //最大的线程的容量(2^29)-1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // runState 用int的高三位表示</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //11100000000000000000000000000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //00000000000000000000000000000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //00100000000000000000000000000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //01000000000000000000000000000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //01100000000000000000000000000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 拆解出运行状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //拆解出来线程数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static int workerCountOf(int c)  { return c &amp; CAPACITY; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //把运行状态和线程数量打包成一个整数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static int ctlOf(int rs, int wc) { return rs | wc; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 线程的增加和减少都是通过CAS来进行的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean compareAndIncrementWorkerCount(int expect) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ctl.compareAndSet(expect, expect + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean compareAndDecrementWorkerCount(int expect) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ctl.compareAndSet(expect, expect - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void decrementWorkerCount() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {} while (! compareAndDecrementWorkerCount(ctl.get()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 阻塞队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 非公平的重入锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ReentrantLock mainLock = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 仅在持有主锁mainLock时访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * .</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Condition termination = mainLock.newCondition();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int largestPoolSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long completedTaskCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile ThreadFactory threadFactory;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 当执行饱和或关闭时调用处理Handler</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile RejectedExecutionHandler handler;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 闲置的线程等待超时时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile long keepAliveTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 是否允许核心线程超时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile boolean allowCoreThreadTimeOut;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 核心线程池的大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile int corePoolSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 线程的极大值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile int maximumPoolSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 默认的被拒执行的Handler</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final RejectedExecutionHandler defaultHandler =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new AbortPolicy();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //Worker实现了AQS和Runnable的接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final class Worker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        extends AbstractQueuedSynchronizer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        implements Runnable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static final long serialVersionUID = 6138294804551838833L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Thread thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Runnable firstTask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile long completedTasks;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Worker(Runnable firstTask) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setState(-1); // inhibit interrupts until runWorker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.firstTask = firstTask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.thread = getThreadFactory().newThread(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** Delegates main run loop to outer runWorker  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            runWorker(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected boolean isHeldExclusively() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return getState() != 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected boolean tryAcquire(int unused) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (compareAndSetState(0, 1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setExclusiveOwnerThread(Thread.currentThread());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected boolean tryRelease(int unused) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setExclusiveOwnerThread(null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setState(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void lock()        { acquire(1); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public boolean tryLock()  { return tryAcquire(1); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void unlock()      { release(1); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public boolean isLocked() { return isHeldExclusively(); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        void interruptIfStarted() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    t.interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (SecurityException ignore) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-execute-的实现">4. execute 的实现<a href="#4-execute-的实现" class="hash-link" aria-label="Direct link to 4. execute 的实现" title="Direct link to 4. execute 的实现">​</a></h3><p>从上面可以看出来上面方法实现主要是通过调用  <strong><code>execute</code></strong> 和 <strong><code>ExecutorCompletionService</code></strong> 这个类。来实现了 <strong><code>submit</code></strong> , <strong><code>doInvokeAny</code></strong>  ,<strong><code>invokeAll</code></strong> 这些方法。下面就来看一下 <strong><code>execute</code></strong> 这方法在 <strong><code>ThreadPoolExecutor</code></strong> 中是如何实现的。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> public void execute(Runnable command) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (command == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Proceed in 3 steps:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 1 如果运行的线程小于corePoolSize，则尝试以给定命令作为其第一个任务启动新线程。对</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * addWorker的调用以原子方式检查runState和workerCount，从而通过返回false防止在不</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 应该添加线程时添加错误警报。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 2. 如果一个任务可以成功地排队，那么我们仍然需要再次检查是否应该添加线程(因为上次检</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 查后已有线程死亡)，或者是否应该在进入这个方法后关闭线程池。因此，我们重新检查状</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 态，如果有必要的话，在停止时回滚队列，或者在没有线程时启动新线程。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 3. 如果无法对任务排队，则尝试添加新线程。如果它失败了，我们知道我们被关闭或饱和，所以拒绝任务。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 所以拒绝任务。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取线程池中线程数量---默认是0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //如果设置了核心线程数先判断核心线程数是不是已经满了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (workerCountOf(c) &lt; corePoolSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (addWorker(command, true))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //判断线程池是否处于运行状态并且还能往队列添加任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int recheck = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //双重检查---如果不是运行状态从队列中删除任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (! isRunning(recheck) &amp;&amp; remove(command))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //根据传入的不同策略处理器处理问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                reject(command);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (workerCountOf(recheck) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                addWorker(null, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //添加非核心线程任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (!addWorker(command, false))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //添加失败根据传入的不同的策略处理器处理问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            reject(command);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>execute</strong> 方法主要做了三件事情：</p><ol><li><strong>添加核心处理线程</strong></li><li><strong>线程池在运行状态，添加任务到任务阻塞队列中</strong></li><li><strong>新增非核心线程处理</strong></li></ol><blockquote><p>在线程池构造函数中有设置keepAliveTime，这个设置的就是非coreThread的存活时间。</p></blockquote><p>通过上面的源码发现主要是 <strong><code>addWorker</code></strong> 方法：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean addWorker(Runnable firstTask, boolean core) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //增加Worker的数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        retry:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int rs = runStateOf(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Check if queue empty only if necessary.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (rs &gt;= SHUTDOWN &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ! (rs == SHUTDOWN &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   firstTask == null &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   ! workQueue.isEmpty()))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int wc = workerCountOf(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (wc &gt;= CAPACITY ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (compareAndIncrementWorkerCount(c))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break retry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                c = ctl.get();  // Re-read ctl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (runStateOf(c) != rs)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    continue retry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //创建Worker并且启动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean workerStarted = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean workerAdded = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Worker w = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            w = new Worker(firstTask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Thread t = w.thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (t != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                final ReentrantLock mainLock = this.mainLock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                mainLock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Recheck while holding lock.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Back out on ThreadFactory failure or if</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // shut down before lock acquired.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int rs = runStateOf(ctl.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (rs &lt; SHUTDOWN ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (t.isAlive()) // precheck that t is startable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            throw new IllegalThreadStateException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        workers.add(w);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        int s = workers.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (s &gt; largestPoolSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            largestPoolSize = s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        workerAdded = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    mainLock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (workerAdded) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    t.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    workerStarted = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (! workerStarted)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                addWorkerFailed(w);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return workerStarted;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上面的代码也是做了两件事情：</p><ol><li>增加worker数量的统计</li><li>创建新的Worker并且启动</li></ol><p>在线程池中的任务处理主要是靠一个 <strong><code>Worker</code></strong> 的内部类进行处理。下面来看一下这个内部类：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private final class Worker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        extends AbstractQueuedSynchronizer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        implements Runnable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * This class will never be serialized, but we provide a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * serialVersionUID to suppress a javac warning.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static final long serialVersionUID = 6138294804551838833L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** Thread this worker is running in.  Null if factory fails. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Thread thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** Initial task to run.  Possibly null. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Runnable firstTask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** Per-thread task counter */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile long completedTasks;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Creates with given first task and thread from ThreadFactory.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param firstTask the first task (null if none)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Worker(Runnable firstTask) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setState(-1); // inhibit interrupts until runWorker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.firstTask = firstTask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.thread = getThreadFactory().newThread(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** Delegates main run loop to outer runWorker  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            runWorker(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected boolean isHeldExclusively() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return getState() != 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected boolean tryAcquire(int unused) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (compareAndSetState(0, 1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setExclusiveOwnerThread(Thread.currentThread());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected boolean tryRelease(int unused) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setExclusiveOwnerThread(null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setState(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void lock()        { acquire(1); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public boolean tryLock()  { return tryAcquire(1); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void unlock()      { release(1); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public boolean isLocked() { return isHeldExclusively(); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        void interruptIfStarted() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    t.interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (SecurityException ignore) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong><code>Worker</code></strong> 继承了 <strong><code>AbstractQueuedSynchronizer</code></strong> 实现了 <strong><code>Runnable</code></strong> 。<strong><code>Worker</code></strong> 中有两个变量：</p><ul><li>Thread变量</li><li>Runnable变量</li></ul><p>第一个是在创建Worker的时候，把Worker变成线程保存起来，也就是通过这样的方式来处理任务，Runnable保存的是创建Worker的时候执行的任务。那么这个Worker的run方法什么时候执行。在前面执行 addWorker 方法的时候，会有一个创建Worker的过程，然后调用了Thread.start()方法。这样就会执行到Worker的run方法，而在run方法中调用的是 <strong><code>ThreadPoolExecutor.runWorker</code></strong>  参数是当前Worker的实例:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">final void runWorker(Worker w) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread wt = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Runnable task = w.firstTask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        w.firstTask = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        w.unlock(); // allow interrupts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean completedAbruptly = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (task != null || (task = getTask()) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                w.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if ((runStateAtLeast(ctl.get(), STOP) ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     (Thread.interrupted() &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    !wt.isInterrupted())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    wt.interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    beforeExecute(wt, task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Throwable thrown = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        task.run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (RuntimeException x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        thrown = x; throw x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (Error x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        thrown = x; throw x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (Throwable x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        thrown = x; throw new Error(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        afterExecute(task, thrown);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    task = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    w.completedTasks++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    w.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            completedAbruptly = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            processWorkerExit(w, completedAbruptly);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>首先获取Worker中的需要处理的任务去处理，当处理完成Worker中的通过获取getTask任务列表中的任务进行处理。根据是否有核心处理线程(Worker)来是否要退出当前Worker:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private Runnable getTask() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean timedOut = false; // Did the last poll() time out?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int rs = runStateOf(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Check if queue empty only if necessary.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                decrementWorkerCount();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int wc = workerCountOf(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 默认情况下core线程不会失效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (compareAndDecrementWorkerCount(c))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //根据是否失效调用任务列表的不同方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Runnable r = timed ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //调用poll，在规定时间内还没有就返回null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //没有就阻塞当前线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    workQueue.take();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (r != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return r;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                timedOut = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException retry) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                timedOut = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5-线程池化的模型图">5. 线程池化的模型图<a href="#5-线程池化的模型图" class="hash-link" aria-label="Direct link to 5. 线程池化的模型图" title="Direct link to 5. 线程池化的模型图">​</a></h3><ul><li><p>从池的空闲线程列表中选择一个 Thread，并且指派它去运行一个已提交的任务(一个 Runnable，Callable 的实现)</p></li><li><p>当任务完成时，将该 Thread 返回给该列表，使其可被重用。</p><p><img loading="lazy" src="https://github.com/mxsm/document/blob/master/image/JSE/Executor%E6%89%A7%E8%A1%8C%E7%9A%84%E9%80%BB%E8%BE%91%E5%9B%BE%E8%A7%A3.jpg?raw=true" alt="图解" class="img_ev3q"> </p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6-线程池拒绝策略">6. 线程池拒绝策略<a href="#6-线程池拒绝策略" class="hash-link" aria-label="Direct link to 6. 线程池拒绝策略" title="Direct link to 6. 线程池拒绝策略">​</a></h3><ul><li><p>CallerRunsPolicy：在任务被拒绝添加后，会调用当前线程池的所在的线程去执行被拒绝的任务</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> public static class CallerRunsPolicy implements RejectedExecutionHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public CallerRunsPolicy() { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!e.isShutdown()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                r.run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ul><ul><li><p>AbortPolicy：直接抛出异常</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    public static class AbortPolicy implements RejectedExecutionHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public AbortPolicy() { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                 &quot; rejected from &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                 e.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ul><ul><li><p>DiscardPolicy：会让被线程池拒绝的任务直接抛弃，不会抛异常也不会执行。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static class DiscardPolicy implements RejectedExecutionHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public DiscardPolicy() { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ul><ul><li><p>DiscardOldestPolicy：DiscardOldestPolicy策略的作用是，当任务呗拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的，再把这个新任务添加进去。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    public static class DiscardOldestPolicy implements RejectedExecutionHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public DiscardOldestPolicy() { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!e.isShutdown()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.getQueue().poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.execute(r);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>自定义策略，只要实现RejectedExecutionHandler接口</p></li></ul><blockquote><p>我是蚂蚁背大象，文章对你有帮助点赞关注我，文章有不正确的地方请您斧正留言评论~谢谢</p></blockquote></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/mxsm/mxsm-website/edit/develop/docs/java/java-se/concurrencemultithreading/threadpool.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2023-08-05T13:42:06.000Z">Aug 5, 2023</time></b> by <b>mxsm</b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/java/java-se/concurrencemultithreading/threadpool-thread-number"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">线程池的数量和线程池中线程数量如何设置-理论篇</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/java/java-se/concurrencemultithreading/threadstate"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">线程的状态</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-线程池的继承关系" class="table-of-contents__link toc-highlight">1. 线程池的继承关系</a></li><li><a href="#2--abstractexecutorservice" class="table-of-contents__link toc-highlight">2.  <strong><code>AbstractExecutorService</code></strong></a></li><li><a href="#3-看看最常用的实现-threadpoolexecutor" class="table-of-contents__link toc-highlight">3. 看看最常用的实现 <strong><code>ThreadPoolExecutor</code></strong></a></li><li><a href="#4-execute-的实现" class="table-of-contents__link toc-highlight">4. execute 的实现</a></li><li><a href="#5-线程池化的模型图" class="table-of-contents__link toc-highlight">5. 线程池化的模型图</a></li><li><a href="#6-线程池拒绝策略" class="table-of-contents__link toc-highlight">6. 线程池拒绝策略</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/mxsm" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 mxsm(蚂蚁背大象), Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.4a7cd42b.js"></script>
<script src="/assets/js/main.5f86cb15.js"></script>
</body>
</html>