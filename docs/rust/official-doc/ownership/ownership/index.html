<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-rust/official-doc/ownership/ownership">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">什么是所有权 | mxsm(蚂蚁背大象)</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://blog.ljbmxsm.com/docs/rust/official-doc/ownership/ownership"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="什么是所有权 | mxsm(蚂蚁背大象)"><meta data-rh="true" name="description" content="什么是所有权"><meta data-rh="true" property="og:description" content="什么是所有权"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://blog.ljbmxsm.com/docs/rust/official-doc/ownership/ownership"><link data-rh="true" rel="alternate" href="https://blog.ljbmxsm.com/docs/rust/official-doc/ownership/ownership" hreflang="en"><link data-rh="true" rel="alternate" href="https://blog.ljbmxsm.com/docs/rust/official-doc/ownership/ownership" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="mxsm(蚂蚁背大象) RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="mxsm(蚂蚁背大象) Atom Feed">




<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-141789564-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-226F0LR9KE"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-226F0LR9KE",{anonymize_ip:!0})</script><link rel="stylesheet" href="/assets/css/styles.efb36c14.css">
<link rel="preload" href="/assets/js/runtime~main.1385124a.js" as="script">
<link rel="preload" href="/assets/js/main.e562c48e.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><div class="announcementBar_mb4j" role="banner"><div class="announcementBarPlaceholder_vyr4"></div><div class="content_knG7 announcementBarContent_xLdY">⭐️ If you like, give it a star on <a target="_blank" rel="noopener noreferrer" href="https://github.com/mxsm/mxsm-website">GitHub</a> and follow me. This web site is updating!! </div><button type="button" aria-label="Close" class="clean-btn close closeButton_CVFx announcementBarClose_gvF7"><svg viewBox="0 0 15 15" width="14" height="14"><g stroke="currentColor" stroke-width="3.1"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate"></b></a><a class="navbar__item navbar__link" href="/docs/intro">Tutorial</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">RocketMQ</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/rocketmq/rocketmq5">RocketMQ 5.0</a></li><li><a class="dropdown__link" href="/docs/rocketmq/rocketmq4">RocketMQ 4.X</a></li><li><a href="https://github.com/apache/rocketmq" target="_blank" class="dropdown__link">RocketMQ GitHub<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://rocketmq.apache.org/" target="_blank" class="dropdown__link">RocketMQ official website<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><a class="navbar__item navbar__link" href="/docs/event-mesh/">EventMesh</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Spring</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/spring/spring-framework">Spring Framework</a></li><li><a class="dropdown__link" href="/docs/spring/spring-boot">Spring Boot</a></li><li><a class="dropdown__link" href="/docs/spring/spring-cloud">Spring Cloud</a></li><li><a href="https://spring.io/" target="_blank" class="dropdown__link">Spring official website<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Java</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/java/java-se">Java SE</a></li><li><a class="dropdown__link" href="/docs/java/java-web">Java Web</a></li><li><a class="dropdown__link" href="/docs/java/java-tools">Java Tools</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Rust</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/rust/official-doc">Rust官方文档(翻译)</a></li><li><a class="dropdown__link" href="/docs/rust/rust-learn/introduction">Rust学习</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">C++</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/java/java-se">Java SE</a></li><li><a class="dropdown__link" href="/docs/java/java-web">Java Web</a></li><li><a class="dropdown__link" href="/docs/java/java-tools">Java Tools</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Cloud Native</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/cloud-native/open-telemetry">OpenTelemetry</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Middleware</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/netty/">Netty</a></li><li><a class="dropdown__link" href="/docs/redis">Redis</a></li><li><a class="dropdown__link" href="/docs/intro">Kafka-改造中</a></li><li><a class="dropdown__link" href="/docs/intro">Etcd-改造中</a></li><li><a class="dropdown__link" href="/docs/docker">Docker</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Database</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/intro">SQL-改造中</a></li><li><a class="dropdown__link" href="/docs/intro">MySQL-改造中</a></li><li><a class="dropdown__link" href="/docs/intro">PostgreSQL-改造中</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Theory</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/intro">SQL</a></li><li><a class="dropdown__link" href="/docs/intro">MySQL</a></li><li><a class="dropdown__link" href="/docs/intro">PostgreSQL</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Others</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/others/blog-building">Blog building</a></li><li><a class="dropdown__link" href="/docs/others/tools">Develop Tools</a></li><li><a class="dropdown__link" href="/docs/intro">PostgreSQL</a></li></ul></div><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/mxsm" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG menuWithAnnouncementBar_GW3s"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/rust/official-doc">概述</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" href="/docs/rust/official-doc/introduction">1. 快速开始</a><button aria-label="Toggle the collapsible sidebar category &#x27;1. 快速开始&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/introduction/installation">1.1. 安装</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/introduction/HelloWorld">1.2 Hello, World!</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/introduction/HelloCargo">1.3.Hello, Cargo!</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/rust/official-doc/guessing-game/guessing-game">2. 编写猜数字游戏</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" href="/docs/rust/official-doc/concepts">3. 常见编程概念</a><button aria-label="Toggle the collapsible sidebar category &#x27;3. 常见编程概念&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/concepts/variables-mutability">3.1. 变量和可变性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/concepts/data-types">3.2. 数据类型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/concepts/functions">3.3.函数</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/rust/official-doc/ownership">4. 理解所有权</a><button aria-label="Toggle the collapsible sidebar category &#x27;4. 理解所有权&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/rust/official-doc/ownership/ownership">4.1. 什么是所有权</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/ownership/references-borrowing">4.2. 引用和借用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/ownership/slice-type">4.3. 切片类型</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" href="/docs/rust/official-doc/structure-related-data">5. 使用结构体来组织相关数据</a><button aria-label="Toggle the collapsible sidebar category &#x27;5. 使用结构体来组织相关数据&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/structure-related-data/defining-instantiating-structs">5.1. 定义和实例化结构体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/structure-related-data/using-structs">5.2. 使用结构体的示例程序</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/structure-related-data/method-syntax">5.3. 方法语法</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" href="/docs/rust/official-doc/enums-pattern-matching">6. 枚举和模式匹配</a><button aria-label="Toggle the collapsible sidebar category &#x27;6. 枚举和模式匹配&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/enums-pattern-matching/defining-enum">6.1. 定义枚举</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/enums-pattern-matching/match-construct">6.2. match控制流构造</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/enums-pattern-matching/concise">6.3. 使用if let进行简洁的控制流</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" href="/docs/rust/official-doc/packages-crates-modules">7. 使用包、板条箱和模块管理日益增长的项目</a><button aria-label="Toggle the collapsible sidebar category &#x27;7. 使用包、板条箱和模块管理日益增长的项目&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/packages-crates-modules/packages-crates">7.1. 包(Package)和板条箱(Crate)</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/packages-crates-modules/modules">7.2. 定义模块以控制作用域和私有性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/packages-crates-modules/paths-referring">7.3. 在模块树中引用项目的路径</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/packages-crates-modules/bringing-paths">7.4. 使用use关键字将路径引入作用域</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/packages-crates-modules/separating-modules">separating-modules</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" href="/docs/rust/official-doc/common-collections">8. 常用集合</a><button aria-label="Toggle the collapsible sidebar category &#x27;8. 常用集合&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/common-collections/vector">8.1. 使用向量（Vectors）存储多个值</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/common-collections/string">8.2. 使用字符串存储UTF-8编码的文本</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/official-doc/common-collections/hashmap">8.3. 在哈希映射中存储具有关联值的键</a></li></ul></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/rust/official-doc/ownership"><span itemprop="name">4. 理解所有权</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">4.1. 什么是所有权</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>什么是所有权</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么是所有权">什么是所有权？<a href="#什么是所有权" class="hash-link" aria-label="Direct link to 什么是所有权？" title="Direct link to 什么是所有权？">​</a></h2><p><em>所有权</em>是一组规则，用于管理Rust程序如何管理内存。所有程序在运行时都必须管理它们使用计算机内存的方式。有些语言具有垃圾回收，它们在程序运行时定期寻找不再使用的内存；而在其他语言中，程序员必须显式地分配和释放内存。Rust采用了第三种方法：通过一套编译器检查的所有权系统来管理内存。如果违反了其中的任何规则，程序将无法编译。所有权的任何特性在程序运行时都不会减慢程序的速度。</p><p>由于所有权对于许多程序员来说是一个新概念，需要一些时间来适应。好消息是，你越是熟悉Rust和所有权系统的规则，你就越容易自然地开发出安全和高效的代码。坚持下去！</p><p>当你理解了所有权，你就会对理解使Rust独特的特性有一个坚实的基础。在本章中，你将通过一些示例来学习所有权，重点放在一个非常常见的数据结构上：字符串。</p><blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="栈和堆"><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap" target="_blank" rel="noopener noreferrer">栈和堆</a><a href="#栈和堆" class="hash-link" aria-label="Direct link to 栈和堆" title="Direct link to 栈和堆">​</a></h3><p>许多编程语言不需要经常考虑栈和堆。但在像Rust这样的系统编程语言中，一个值是在栈上还是堆上存储，会影响语言的行为以及为什么你必须做出某些决策。所有权的某些部分将在本章后面与栈和堆相关的内容中进行描述，因此在这里进行简要解释以做准备。</p><p>栈和堆都是程序在运行时可以使用的内存部分，但它们的结构方式不同。栈按照它们得到值的顺序存储值，并以相反的顺序删除值。这被称为<em>后进先出</em>。想象一下一堆盘子：当你添加更多的盘子时，你将它们放在堆的顶部，当你需要一个盘子时，你从顶部取出一个。在堆栈上添加或删除数据被称为<em>推送到栈上</em>或<em>从栈上弹出</em>。在栈上存储的所有数据必须具有已知的固定大小。大小在编译时未知或可能更改的数据必须存储在堆上。</p><p>堆不是那么有组织：当你将数据放入堆时，你请求一定数量的空间。内存分配器找到一个足够大的空闲位置，将其标记为正在使用，并返回一个<em>指针</em>，即该位置的地址。这个过程被称为<em>在堆上分配</em>，有时缩写为只是<em>分配</em>（在堆上推送值不被视为分配）。由于堆上指针是已知的固定大小，因此你可以将指针存储在栈上，但当你需要实际数据时，你必须遵循指针。想象自己坐在餐厅里。当你进入时，你告诉主持人你的小组人数，主持人找到一个足够大的空桌，并带你过去。如果你的小组中有人迟到，他们可以问你坐在哪里找到你。</p><p>与在堆上分配相比，在栈上进行推送更快，因为内存分配器无需搜索存储新数据的位置；该位置总是在栈的顶部。相比之下，在堆上分配空间需要更多的工作，因为内存分配器必须首先找到足够大的空间来容纳数据，然后执行簿记以为下次分配做准备。</p><p>访问堆中的数据比访问栈上的数据更慢，因为你必须遵循指针才能到达那里。如果处理器在内存中跳来跳去，它就会更快。继续这个类比，考虑一位服务员从许多桌子上收集订单。在处理多个桌子的订单之前，集中处理一张桌子上的所有订单是最高效的。从A桌收取订单，然后从B桌收取订单，然后再从A桌收取订单，最后再从B桌收取订单会导致速度更慢。同样地，如果处理器在栈上的数据附近工作，而不是在堆上的数据附近，它的工作效率会更高。</p><p>当你的代码调用一个函数时，传递给函数的值（包括可能在堆上的数据的指针）以及函数的局部变量都被推送到栈上。当函数结束时，这些值将从栈上弹出。</p><p>跟踪哪些代码部分在使用堆上的哪些数据，最小化堆上的重复数据量，并清理不再使用的堆上数据，以便不会用尽空间，这些都是所有权解决的问题。一旦你理解了所有权，你就不需要经常考虑栈和堆，但是知道所有权的主要目的是管理堆数据可以帮助解释它为什么以这种方式工作。</p></blockquote><p>Ownership 是 Rust 中的一个核心概念，它定义了如何管理内存和变量的生命周期。以下是 Ownership 的规则：</p><ol><li>Rust 中的每个值都有一个所有者（owner）。</li><li>同一时间内，一个值只能有一个所有者。</li><li>当所有者（owner）超出作用域时，这个值将会被 dropped（释放）。</li></ol><p>对于变量的作用域，它指的是一个变量在程序中有效的范围。例如，对于以下代码：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let s = &quot;hello&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>变量 <code>s</code> 引用了一个字符串字面量，其中字符串的值硬编码在程序的文本中。该变量的有效范围从它声明的位置开始一直持续到当前 <em>scope</em> 结束。以下是对变量 <code>s</code> 的有效范围进行注释标记的示例：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    {                      // 此处 s 无效，尚未声明</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s = &quot;hello&quot;;   // 从此处起，s 是有效的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用 s 进行操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }                      // 此作用域结束，s 不再有效</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>换句话说，以下是重要的时间点：</p><ul><li>当 <code>s</code> 进入 <em>scope</em> 时，它是有效的。</li><li>它一直有效，直到它超出 <em>scope</em>。</li></ul><p>目前，作用域和变量有效的时间关系与其他编程语言中的类似。接下来，我们将通过引入 <code>String</code> 类型来加深对 Ownership 的理解。</p><p>在 Rust 中，为了说明 Ownership 规则，我们需要一个比前面章节涉及的数据类型更复杂的数据类型。前面提到的数据类型都是已知大小的，可以存储在栈上，并在其 <em>scope</em> 结束时弹出栈，如果代码的其他部分需要在不同的 <em>scope</em> 中使用相同的值，可以进行快速且轻松的复制。但是，我们希望看到存储在堆上的数据，并探索 Rust 如何知道何时清理这些数据。<code>String</code> 类型就是一个很好的例子。</p><p>我们将重点关注与所有权相关的 <code>String</code> 部分。这些方面也适用于其他复杂的数据类型，无论是标准库提供的还是由您自己创建的。有关更深入的 <code>String</code> 详细信息，请参阅第 8 章。</p><p>我们已经见过字符串字面量，其中字符串的值硬编码在我们的程序中。字符串字面量很方便，但并不适用于每种情况，因为它们是不可变的。而且，并非每个字符串值在编写代码时都是已知的，例如，如果我们想要接受用户输入并存储它，我们就不能使用字符串字面量。为了应对这些情况，Rust 提供了第二种字符串类型 <code>String</code>，它管理在堆上分配的数据，因此能够存储在编译时未知的文本量。您可以使用 <code>from</code> 函数将字符串字面量转换为 <code>String</code> 类型，如下所示：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let s = String::from(&quot;hello&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>双冒号 <code>::</code> 运算符允许我们将特定的 <code>from</code> 函数命名空间化为 <code>String</code> 类型，而不是使用诸如 <code>string_from</code> 等名称。我们将在第 5 章的 <a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#method-syntax" target="_blank" rel="noopener noreferrer">“Method Syntax”</a> 中更深入地讨论这个语法，以及在第 7 章的 <a href="https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" target="_blank" rel="noopener noreferrer">“Paths for Referring to an Item in the Module Tree”</a> 中讨论使用模块进行命名空间化。</p><p>与字符串字面量不同，<code>String</code> 类型是可</p><p>变的：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.push_str(&quot;, world!&quot;); // push_str() 将一个字符串字面量附加到 String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, s); // 这将打印 `hello, world!`</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>那么，这里有什么区别呢？为什么 <code>String</code> 可以被修改，而字符串字面量则不能？区别在于这两种类型处理内存的方式。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="内存与分配">内存与分配<a href="#内存与分配" class="hash-link" aria-label="Direct link to 内存与分配" title="Direct link to 内存与分配">​</a></h3><p>对于字符串字面值，在编译时我们已经知道了内容，所以文本直接硬编码进了最终的可执行文件中。这就是为什么字符串字面值快速高效的原因。但是这些特性只有在字符串字面值是不可变的情况下才成立。不幸的是，对于那些大小在编译时未知且在程序运行时可能发生变化的文本片段，我们无法在二进制文件中为每个文本片段分配内存空间。</p><p>而对于 <code>String</code> 类型，为了支持可变且可以扩展的文本内容，我们需要在堆上分配一块未知大小的内存来保存内容。这意味着：</p><ul><li>内存必须在运行时向内存分配器申请。</li><li>我们需要一种方法在我们使用完 <code>String</code> 后将内存返回给内存分配器。</li></ul><p>第一部分由我们完成：当我们调用 <code>String::from</code> 时，它的实现会请求所需的内存。这在大多数编程语言中都是普遍的做法。</p><p>然而，第二部分与众不同。在拥有<em>垃圾回收器（GC）</em>的语言中，GC会跟踪和清理不再使用的内存，我们不需要考虑这个问题。但是在大多数没有垃圾回收器的语言中，我们需要自己判断何时内存不再使用，并调用代码显式地释放它，就像我们请求内存时一样。在历史上，正确地处理这个问题一直是一个棘手的编程问题。如果忘记释放内存，会造成内存泄漏。如果过早释放，可能导致无效的变量。如果释放两次，也是一个错误。我们需要保证每一次 <code>allocate</code> 都有与之对应的一次 <code>free</code>。</p><p>Rust 采取了不同的方式：一旦拥有内存的变量超出了其作用域，内存就会自动返回。下面是我们使用 <code>String</code> 代替字符串字面值的作用域示例（来自列表 4-1）：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s = String::from(&quot;hello&quot;); // s 从这一点开始有效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用 s 做一些事情</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }                                  // 这个作用域结束，s 不再有效</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当 <code>s</code> 超出作用域时，就有一个自然的时机可以将 <code>String</code> 需要的内存返回给内存分配器。当变量超出作用域时，Rust 会自动为我们调用一个特殊的函数，这个函数被称为 <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop" target="_blank" rel="noopener noreferrer"><code>drop</code></a>，它是 <code>String</code> 的作者可以用来返回内存的地方。Rust 会在闭括号处自动调用 <code>drop</code>。</p><blockquote><p>注意：在 C++ 中，这种在项目生命周期结束时释放资源的模式有时被称为<em>资源获取即初始化（RAII）</em>。如果你使用过 RAII 模式，那么 Rust 中的 <code>drop</code> 函数会很熟悉。</p></blockquote><p>这种模式对 Rust 代码的编写产生了深远影响。虽然现在看起来很简单，但在更复杂的情况下，当我们想让多个变量使用我们在堆上分配的数据时，代码的行为可能会出乎意料。让我们现在探讨一些这样的情况。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="变量和数据的移动交互">变量和数据的移动交互<a href="#变量和数据的移动交互" class="hash-link" aria-label="Direct link to 变量和数据的移动交互" title="Direct link to 变量和数据的移动交互">​</a></h3><p>在 Rust 中，多个变量可以以不同的方式与相同的数据进行交互。让我们看一个使用整数的示例，如列表 4-2 所示。</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    let x = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let y = x;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>列表 4-2：将变量 <code>x</code> 的整数值赋给 <code>y</code></p><p>我们可以猜测这段代码在做什么：“将值 <code>5</code> 绑定到 <code>x</code>；然后复制 <code>x</code> 中的值并将其绑定到 <code>y</code>。” 现在我们有了两个变量 <code>x</code> 和 <code>y</code>，并且它们都等于 <code>5</code>。这是实际发生的情况，因为整数是简单的值，具有已知且固定的大小，这两个 <code>5</code> 的值都被推送到堆栈上。</p><p>现在我们来看看 <code>String</code> 版本：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = s1;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这看起来非常相似，所以我们可能会假设它的工作方式也是相同的：即第二行会复制 <code>s1</code> 中的值，并将其绑定到 <code>s2</code>。但实际情况并非如此。</p><p>看一下图 4-1，了解 <code>String</code> 在内部发生的情况。<code>String</code> 由三部分组成，如图左侧所示：一个指向保存字符串内容的内存的指针、一个长度和一个容量。这组数据存储在堆栈上。右侧是保存内容的堆上内存。</p><p><img loading="lazy" src="https://doc.rust-lang.org/book/img/trpl04-01.svg" alt="两个表：第一个表包含 s1 在堆栈上的表示，由长度（5）、容量（5）和指向第二个表中第一个值的指针组成。第二个表包含在堆上保存字符串数据的内存，按字节排列。" class="img_ev3q"></p><p>图 4-1：保存值为 <code>&quot;hello&quot;</code> 的 <code>String</code> 在内存中的表示，绑定到 <code>s1</code></p><p>长度表示 <code>String</code> 目前使用的内容内存量，以字节为单位。容量是 <code>String</code> 从分配器中获得的总内存量，也以字节为单位。长度和容量之间的区别在这个上下文中并不重要，所以现在可以忽略容量。</p><p>当我们将 <code>s1</code> 赋值给 <code>s2</code> 时，<code>String</code> 数据被复制，这意味着我们复制了在堆栈上的指针、长度和容量。但是我们没有复制指针所指向的堆上数据。换句话说，内存中的数据表示看起来像图 4-2。</p><p><img loading="lazy" src="https://doc.rust-lang.org/book/img/trpl04-02.svg" alt="三个表：分别表示 s1 和 s2 在堆栈上的字符串数据，它们都指向相同的堆上字符串数据。" class="img_ev3q"></p><p>图 4-2：表示具有 <code>s1</code> 的指针、长度和容量的变量 <code>s2</code></p><p>这个表示与图 4-3 不同，如果 Rust 复制堆上的数据，内存会是这个样子。如果 Rust 这样做，<code>s2 = s1</code> 的操作会在运行时性能方面非常昂贵，因为堆上的数据可能很大。</p><p><img loading="lazy" src="https://doc.rust-lang.org/book/img/trpl04-03.svg" alt="四个表：两个表示 s1 和 s2 在堆栈上的数据，它们都指向各自的堆上字符串数据副本。" class="img_ev3q"></p><p>图 4-3：如果 Rust 也复制堆上的数据，<code>s2 = s1</code> 可能会执行的另一种情况</p><p>前面我们说过，当一个变量超出作用域时，Rust 会自动调用 <code>drop</code> 函数并清理该变量的堆内存。但是图 4-2 显示了两个数据指针指向同一位置。这是一个问题：当 <code>s2</code> 和 <code>s1</code> 超出作用域时，它们都会尝试释放同一块内存。这被称为<em>双重释放（double free）</em>错误，是我们之前提到的内存安全性错误之一。释放内存两次会导致内存损坏，可能导致安全漏洞。</p><p>为了确保内存安全，<code>let s2 = s1;</code> 后，Rust 将 <code>s1</code> 视为无效。因此，当 <code>s1</code> 超出作用域时，Rust 不需要释放任何东西。看看在创建 <code>s2</code> 后尝试使用 <code>s1</code> 会发生什么；它不会工</p><p>作：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = s1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}, world!&quot;, s1);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>你会得到一个类似于这样的错误，因为 Rust 阻止你使用无效的引用：</p><div class="language-console codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-console codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ cargo run</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">error[E0382]: borrow of moved value: `s1`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> --&gt; src/main.rs:5:28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2 |     let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3 |     let s2 = s1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |              -- value moved here</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4 |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5 |     println!(&quot;{}, world!&quot;, s1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |                            ^^ value borrowed here after move</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">help: consider cloning the value if the performance cost is acceptable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3 |     let s2 = s1.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |                ++++++++</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">For more information about this error, try `rustc --explain E0382`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">error: could not compile `ownership` due to previous error</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果你在使用其他语言时听说过“浅复制”和“深复制”这些术语，在不复制数据的情况下复制指针、长度和容量的概念可能听起来像是在做浅复制。但由于 Rust 还使第一个变量无效，所以它被称为<em>移动</em>，而不是浅复制。在这个示例中，我们会说 <code>s1</code> 被<em>移动</em>到了 <code>s2</code> 中。因此，实际上发生的情况如图 4-4 所示。</p><p><img loading="lazy" src="https://doc.rust-lang.org/book/img/trpl04-04.svg" alt="三个表：分别表示 s1 和 s2 在堆栈上的字符串数据，它们都指向相同的堆上字符串数据。表 s1 是灰色的，因为 s1 不再有效；只有 s2 可以用于访问堆上的数据。" class="img_ev3q"></p><p>图 4-4：在 <code>s1</code> 无效后内存中的表示</p><p>这解决了我们的问题！只有 <code>s2</code> 有效，当它超出作用域时它将单独释放内存，问题解决。</p><p>此外，这也暗示了一个设计选择：Rust 永远不会自动创建“深度”复制的数据。因此，任何<em>自动</em>复制都可以认为在运行时性能方面是廉价的。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="变量和克隆交互">变量和克隆交互<a href="#变量和克隆交互" class="hash-link" aria-label="Direct link to 变量和克隆交互" title="Direct link to 变量和克隆交互">​</a></h4><p>如果我们确实想要深度复制 <code>String</code> 的堆数据，而不仅仅是堆栈数据，我们可以使用一个常见的方法叫做 <code>clone</code>。我们将在第 5 章讨论方法语法，但因为方法是许多编程语言中常见的特性，你可能以前见过它们。</p><p>以下是 <code>clone</code> 方法的示例：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = s1.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这可以正常工作，并明确地产生了图 4-3 中显示的行为，堆数据确实被复制。</p><p>当你看到一个对 <code>clone</code> 的调用时，你知道正在执行一些随机代码，而这些代码可能是昂贵的。这是一个视觉指示，表示正在发生一些不同的事情。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="仅限堆栈数据copy">仅限堆栈数据：Copy<a href="#仅限堆栈数据copy" class="hash-link" aria-label="Direct link to 仅限堆栈数据：Copy" title="Direct link to 仅限堆栈数据：Copy">​</a></h4><p>还有一个我们尚未讨论的问题。使用整数的代码——部分显示在列表 4-2 中——有效且有效：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    let x = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let y = x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;x = {}, y = {}&quot;, x, y);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>但这段代码似乎与我们刚刚学到的相矛盾：我们没有调用 <code>clone</code>，但 <code>x</code> 仍然有效，没有被移动到 <code>y</code> 中。</p><p>原</p><p>因是编译时大小已知的类型（例如整数）完全存储在堆栈上，因此实际值的复制速度很快。这意味着我们没有理由在创建变量 <code>y</code> 后阻止 <code>x</code> 有效。换句话说，在这里深度复制和浅复制之间没有区别，因此可以省略调用 <code>clone</code>。</p><p>Rust 有一个特殊的注解叫做 <code>Copy</code> 特性，我们可以将其放在存储在堆栈上的类型上，例如整数（我们将在<a href="https://doc.rust-lang.org/book/ch10-02-traits.html" target="_blank" rel="noopener noreferrer">第 10 章</a>中详细讨论特性）。如果一个类型实现了 <code>Copy</code> 特性，使用它的变量不会被移动，而是进行简单的复制，使其在赋值给另一个变量后仍然有效。</p><p>如果类型或其部分实现了 <code>Drop</code> 特性，Rust 不会允许我们给该类型加上 <code>Copy</code> 注解。如果该类型在值超出作用域时需要发生特殊情况，并且我们为该类型添加了 <code>Copy</code> 注解，将会得到一个编译时错误。有关如何将 <code>Copy</code> 注解添加到您的类型以实现特性的信息，请参阅附录 C 中的 <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html" target="_blank" rel="noopener noreferrer">“可派生特性”</a>。</p><p>那么，哪些类型实现了 <code>Copy</code> 特性？您可以查看给定类型的文档来确定，但通常情况下，任何一组简单标量值都可以实现 <code>Copy</code> 特性，而任何需要分配或是某种形式的资源的类型都不能实现 <code>Copy</code>。以下是一些实现了 <code>Copy</code> 特性的类型：</p><ul><li>所有的整数类型，比如 <code>u32</code>。</li><li>布尔类型 <code>bool</code>，其值为 <code>true</code> 或 <code>false</code>。</li><li>所有浮点类型，比如 <code>f64</code>。</li><li>字符类型 <code>char</code>。</li><li>元组，如果它们只包含同样实现了 <code>Copy</code> 特性的类型。例如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 不实现。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="所有权和函数">所有权和函数<a href="#所有权和函数" class="hash-link" aria-label="Direct link to 所有权和函数" title="Direct link to 所有权和函数">​</a></h3><p>将值传递给函数的机制与将值赋给变量的机制类似。传递变量给函数将移动或复制，就像赋值一样。列表 4-3 展示了一个示例，其中使用了一些标注，显示了变量何时进入和退出作用域。</p><p>文件名：src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = String::from(&quot;hello&quot;);  // s 进入作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    takes_ownership(s);             // s 的值移动到函数里...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    // ... 所以在这里不再有效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = 5;                      // x 进入作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    makes_copy(x);                  // x 应该移动函数里，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    // 但 i32 是 Copy 的，所以在后面依然可以使用 x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} // 这里 x 先退出作用域，然后是 s。由于 s 的值已经被移动，所以在这里没有特殊的事情发生。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn takes_ownership(some_string: String) { // some_string 进入作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, some_string);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} // 这里，some_string 被移动进入函数，然后在这里离开作用域并调用 `drop`。背后的内存被释放。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn makes_copy(some_integer: i32) { // some_integer 进入作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, some_integer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} // 这里，some_integer 离开作用域。没有特殊的事情发生。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>列表 4-3：具有所有权和作用域标注的函数</p><p>如果我们尝试在调用 <code>takes_ownership</code> 后使用 <code>s</code>，Rust 将会在编译时报错。这些静态检查保护我们免受错误。尝试向 <code>main</code> 函数中添加使用 <code>s</code> 和 <code>x</code> 的代码，以查看您可以在哪里使用它们，以及所有权规则在哪里阻止您这样做。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="返回值和作用域">返回值和作用域<a href="#返回值和作用域" class="hash-link" aria-label="Direct link to 返回值和作用域" title="Direct link to 返回值和作用域">​</a></h3><p>返回值也会转移所有权。列表 4-4 显示了一个返回某个值的函数的示例，其中使用了与列表 4-3 中相似的标注。</p><p>文件名：src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = gives_ownership();         // gives_ownership 将返回值移给 s1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = String::from(&quot;hello&quot;);     // s2 进入作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s3 = takes_and_gives_back(s2);  // s2 被移动到 takes_and_gives_back 函数中，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        // 它也将返回值移给 s3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} // 这里，s3 首先离开作用域，然后是 s2。但由于 s2 的值被移动，所以没有特殊的事情发生。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn gives_ownership() -&gt; String {             // gives_ownership 将它的返回值移给调用它的函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             // （这就是为什么后面没有分号，返回值就是没有分号的表达式的值）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let some_string = String::from(&quot;yours&quot;); // some_string 进入作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    some_string                              // some_string 被移出作用域并返回给调用的函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个函数会将传入的 String 返回给调用者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 进入作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a_string  // a_string 被移出作用域并返回给调用的函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>列表 4-4：传递参数的所有权</p><p>但是这样做对每个函数都返回所有权并返回</p><p>所有权的模式并不高效。如果有一个函数需要从调用它的代码获取一些数据的所有权并返回所有权，我们通常希望在不将所有权移动到并从函数返回的情况下实现。</p><p>对于这种情况，Rust 提供了引用（reference）的概念，它允许您通过传递引用而不是值来传递数据。引用允许多个部分同时访问数据，而不会导致所有权转移。我们将在下一节中讨论引用。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/mxsm/mxsm-website/edit/develop/docs/rust/official-doc/ownership/01-ownership.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2023-08-27T12:29:47.000Z">Aug 27, 2023</time></b> by <b>mxsm</b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/rust/official-doc/ownership"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Understanding Ownership</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/rust/official-doc/ownership/references-borrowing"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">4.2. 引用和借用</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#什么是所有权" class="table-of-contents__link toc-highlight">什么是所有权？</a><ul><li><a href="#内存与分配" class="table-of-contents__link toc-highlight">内存与分配</a></li><li><a href="#变量和数据的移动交互" class="table-of-contents__link toc-highlight">变量和数据的移动交互</a><ul><li><a href="#变量和克隆交互" class="table-of-contents__link toc-highlight">变量和克隆交互</a></li><li><a href="#仅限堆栈数据copy" class="table-of-contents__link toc-highlight">仅限堆栈数据：Copy</a></li></ul></li><li><a href="#所有权和函数" class="table-of-contents__link toc-highlight">所有权和函数</a></li><li><a href="#返回值和作用域" class="table-of-contents__link toc-highlight">返回值和作用域</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/mxsm" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 mxsm(蚂蚁背大象), Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.1385124a.js"></script>
<script src="/assets/js/main.e562c48e.js"></script>
</body>
</html>